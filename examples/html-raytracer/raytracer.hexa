module {
	class Vector {
		var x: Float
		var y: Float
		var z: Float
		new(x, y, z) {
			this.x = x
			this.y = y
			this.z = z
		}

		static function times(k: Float, v: Vector) {
			return new Vector(k * v.x, k * v.y, k * v.z)
		}

		static function minus(v1: Vector, v2: Vector) {
			return new Vector(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z)
		}

		static function plus(v1: Vector, v2: Vector) {
			return new Vector(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z)
		}

		static function dot(v1: Vector, v2: Vector) {
			return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z
		}

		static function mag(v: Vector) {
			return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
		}

		static function norm(v: Vector) {
			let mag = Vector.mag(v)
			let div = strictEqual(mag, 0) ? infinity : 1.0 / mag
			return Vector.times(div, v)
		}

		static function cross(v1: Vector, v2: Vector) {
			return new Vector(
				v1.y * v2.z - v1.z * v2.y,
				v1.z * v2.x - v1.x * v2.z,
				v1.x * v2.y - v1.y * v2.x
			)
		}
	}

	class Color {
		var r: Float
		var g: Float
		var b: Float
		new(r, g, b) {
			this.r = r
			this.g = g
			this.b = b
		}

		static function scale(k: Float, v: Color) {
			return new Color(k * v.r, k * v.g, k * v.b)
		}

		static function plus(v1: Color, v2: Color) {
			return new Color(v1.r + v2.r, v1.g + v2.g, v1.b + v2.b)
		}

		static function times(v1: Color, v2: Color) {
			return new Color(v1.r * v2.r, v1.g * v2.g, v1.b * v2.b)
		}

		static let white = new Color(1.0, 1.0, 1.0)
		static let grey = new Color(0.5, 0.5, 0.5)
		static let black = new Color(0.0, 0.0, 0.0)
		static let background = Color.black
		static let defaultColor = Color.black

		static function toDrawingColor(c: Color) {
			let legalize = d => (d > 1 ? 1 : d)
			return {
				r: Math.floor(legalize(c.r) * 255),
				g: Math.floor(legalize(c.g) * 255),
				b: Math.floor(legalize(c.b) * 255)
			}
		}
	}

	class Camera {
		var forward: Vector
		var right: Vector
		var up: Vector
		var pos: Vector

		new(pos: Vector, lookAt: Vector) {
			this.pos = pos
			let down = new Vector(0.0, -1.0, 0.0)
			this.forward = Vector.norm(Vector.minus(lookAt, this.pos))
			this.right = Vector.times(
				1.5,
				Vector.norm(Vector.cross(this.forward, down))
			)
			this.up = Vector.times(
				1.5,
				Vector.norm(Vector.cross(this.forward, this.right))
			)
		}
	}

	interface Ray {
		var start: Vector
		var dir: Vector
	}

	interface Intersection {
		var thing: Thing
		var ray: Ray
		var dist: Float
	}

	interface Surface {
		var diffuse: (pos: Vector) => Color
		var specular: (pos: Vector) => Color
		var reflect: (pos: Vector) => Float
		var roughness: Float
	}

	interface Thing {
		var intersect: (ray: Ray) => Intersection
		var normal: (pos: Vector) => Vector
		var surface: Surface
	}

	interface Light {
		var pos: Vector
		var color: Color
	}

	interface Scene {
		var things: [Thing]
		var lights: [Light]
		var camera: Camera
	}

	class Sphere implements Thing {
		var radius2: Float
		var center: Vector
		var surface: Surface

		new(center: Vector, radius: Float, surface: Surface) {
			this.center = center
			this.surface = surface
			this.radius2 = radius * radius
		}

		function normal(pos: Vector): Vector {
			return Vector.norm(Vector.minus(pos, this.center))
		}

		function intersect(ray: Ray) {
			let eo = Vector.minus(this.center, ray.start)
			let v = Vector.dot(eo, ray.dir)
			var dist = 0.0
			if (v >= 0) {
				let disc = this.radius2 - (Vector.dot(eo, eo) - v * v)
				if (disc >= 0) {
					dist = v - Math.sqrt(disc)
				}
			}
			if (strictEqual(dist, 0)) {
				return null
			} else {
				return { thing: this, ray: ray, dist: dist }
			}
		}
	}

	class Plane implements Thing {
		var normal: (pos: Vector) => Vector
		var intersect: (ray: Ray) => Intersection
		var surface: Surface

		new(norm: Vector, offset: Float, surface: Surface) {
			this.surface = surface
			this.normal = function(pos: Vector) {
				return norm
			}
			this.intersect = function(ray: Ray): Intersection {
				let denom = Vector.dot(norm, ray.dir)

				if (denom > 0) {
					return null
				} else {
					let dist = (Vector.dot(norm, ray.start) + offset) / -denom
					return { thing: this, ray: ray, dist: dist }
				}
			}
		}
	}

	class Surfaces {
		static let shiny: Surface = {
			diffuse: function(pos) {
				return Color.white
			},
			specular: function(pos) {
				return Color.grey
			},
			reflect: function(pos) {
				return 0.7
			},
			roughness: 250
		}

		static let checkerboard: Surface = {
			diffuse: function(pos) {
				if ((Math.floor(pos.z) + Math.floor(pos.x)) % 2 != 0) {
					return Color.white
				} else {
					return Color.black
				}
			},
			specular: function(pos) {
				return Color.white
			},
			reflect: function(pos) {
				if ((Math.floor(pos.z) + Math.floor(pos.x)) % 2 != 0) {
					return 0.1
				} else {
					return 0.7
				}
			},
			roughness: 150
		}
	}

	class RayTracer {
		private let maxDepth = 5
		new () {}

		private function intersections(ray: Ray, scene: Scene) {
			var infinity = infinity
			var closest = infinity
			var infinity = infinity
			var closestInter: Intersection = undefined
			for (thing in scene.things) {
				let inter = thing.intersect(ray)
				if (inter != null && inter.dist < closest) {
					closestInter = inter
					closest = inter.dist
				}
			}
			return closestInter
		}

		private function testRay(ray: Ray, scene: Scene) {
			let isect = this.intersections(ray, scene)
			if (isect != null) {
				return isect.dist
			} else {
				return undefined
			}
		}

		private function traceRay(ray: Ray, scene: Scene, depth: Float): Color {
			let isect = this.intersections(ray, scene)
			if (strictEqual(isect, undefined)) {
				return Color.background
			} else {
				return this.shade(isect, scene, depth)
			}
		}

		private function shade(isect: Intersection, scene: Scene, depth: Float) {
			let d = isect.ray.dir
			let pos = Vector.plus(Vector.times(isect.dist, d), isect.ray.start)
			let normal = isect.thing.normal(pos)
			let reflectDir = Vector.minus(
				d,
				Vector.times(2, Vector.times(Vector.dot(normal, d), normal))
			)
			let naturalColor = Color.plus(
				Color.background,
				this.getNaturalColor(isect.thing, pos, normal, reflectDir, scene)
			)
			let reflectedColor =
				(depth >= this.maxDepth)
					? Color.grey
					: this.getReflectionColor(
							isect.thing,
							pos,
							normal,
							reflectDir,
							scene,
							depth
						)
			return Color.plus(naturalColor, reflectedColor)
		}

		private function getReflectionColor(
			thing: Thing,
			pos: Vector,
			normal: Vector,
			rd: Vector,
			scene: Scene,
			depth: Float
		) {
			return Color.scale(
				thing.surface.reflect(pos),
				this.traceRay({ start: pos, dir: rd }, scene, depth + 1)
			)
		}

		private function getNaturalColor(
			thing: Thing,
			pos: Vector,
			norm: Vector,
			rd: Vector,
			scene: Scene
		) {
			let addLight = (col, light) => {
				let ldis = Vector.minus(light.pos, pos)
				let livec = Vector.norm(ldis)
				let neatIsect = this.testRay({ start: pos, dir: livec }, scene)
				let isInShadow =
					strictEqual(neatIsect, undefined) ? false : neatIsect <= Vector.mag(ldis)
				if (isInShadow) {
					col
				} else {
					let illum = Vector.dot(livec, norm)
					let lcolor =
						(illum > 0) ? Color.scale(illum, light.color) : Color.defaultColor
					let specular = Vector.dot(livec, Vector.norm(rd))
					let scolor =
						(specular > 0)
							? Color.scale(
									Math.pow(specular, thing.surface.roughness),
									light.color
								)
							: Color.defaultColor
					Color.plus(
						col,
						Color.plus(
							Color.times(thing.surface.diffuse(pos), lcolor),
							Color.times(thing.surface.specular(pos), scolor)
						)
					)
				}
			}
			return scene.lights.reduce(addLight, Color.defaultColor)
		}

		function render(scene, ctx, screenWidth, screenHeight) {
			let getPoint = (x: Int, y: Int, camera: Camera) => {
				let recenterX: (pos: Int) => Float = x => (x - screenWidth / 2.0) / 2.0 / screenWidth
				let recenterY: (pos: Int) => Float = y => -(y - screenHeight / 2.0) / 2.0 / screenHeight
				Vector.norm(
					Vector.plus(
						camera.forward,
						Vector.plus(
							Vector.times(recenterX(x), camera.right),
							Vector.times(recenterY(y), camera.up)
						)
					)
				)
			}

			for (y in screenHeight) {
				for (x in screenWidth) {
					let color = this.traceRay(
						{ start: scene.camera.pos, dir: getPoint(x, y, scene.camera) },
						scene,
						0
					)
					let c = Color.toDrawingColor(color)
					ctx.fillStyle =
						"rgb(" + (c.r) + ", " + (c.g) + ", " + (c.b) + ")"
					ctx.fillRect(x, y, x + 1, y + 1)
				}
			}
		}
	}
}

function defaultScene(): Scene {
	return {
		things: [
			new Plane(new Vector(0.0, 1.0, 0.0), 0.0, Surfaces.checkerboard),
			new Sphere(new Vector(0.0, 1.0, -0.25), 1.0, Surfaces.shiny),
			new Sphere(new Vector(-1.0, 0.5, 1.5), 0.5, Surfaces.shiny)
		],
		lights: [
			{ pos: new Vector(-2.0, 2.5, 0.0), color: new Color(0.49, 0.07, 0.07) },
			{ pos: new Vector(1.5, 2.5, 1.5), color: new Color(0.07, 0.07, 0.49) },
			{ pos: new Vector(1.5, 2.5, -1.5), color: new Color(0.07, 0.49, 0.071) },
			{ pos: new Vector(0.0, 3.5, 0.0), color: new Color(0.21, 0.21, 0.35) }
		],
		camera: new Camera(new Vector(3.0, 2.0, 4.0), new Vector(-1.0, 0.5, 0.0))
	}
}

function exec() {
	let canv = document.createElement("canvas")
	canv.width = 256
	canv.height = 256
	document.body.appendChild(canv)
	let ctx = canv.getContext("2d")
	let rayTracer = new RayTracer()
	rayTracer.render(defaultScene(), ctx, 256, 256)
}

exec()
