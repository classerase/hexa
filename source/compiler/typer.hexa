// The Hexa Compiler
// Copyright (C) 2018  Oleg Petrenko
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

module {
	class Typer {
		new () {}
		function fillFiles(collected: [Node]): Void {
			function fillModuleNamespace(m: Node) {
				var el = null
				var root: String? = null
				switch (m) {
					case Node.TModule(path, els):
					el = els
					root = path.join('.')
					case _: throw 'Unreachable #2'
				}

				if (namespaces[root] == null) {
					namespaces[root] = m
				} else {
					var els = null
					switch (namespaces[root]) {
						case Node.TModule(_, el): els = el
						case _: throw 'Unreachable #1'
					}
					while (el.length > 0) els.push(el.pop())
				}

				{
					var els = null
					switch (namespaces[root]) {
						case Node.TModule(_, el): els = el
						case _: throw 'Unreachable #4'
					}

					for (e in els) {
						var name = nameOfModuleItem(e)
						var found = false
						for (e in els) {
							if (nameOfModuleItem(e) == name) {
								if (found) throw ('Type `\(name)` already exists in module')
								if (!found) found = true
							}
						}
					}
				}
			}

			// Let's fill global namespaces first to avoid delayed expansion
			for (file in collected) {
				var didInit = false
				for (e in file) switch (e) {
					case Node.TModule(path, el):
						if (didInit) throw 'Modules should follow before expressions'
						fillModuleNamespace(e)
					case _:
						didInit = true
				}
			}

			var intermediate = []

			// Fill intermediate non-existsing modules (module aaa.not_exists.bbb {})
			{
				var intermediateSubs = []
				for (ns in namespaces.keys()) {
					var path = ns.split('.')
					var namespace = path.shift()
					function check(namespace) {
						if (namespaces[namespace] == null && intermediate.indexOf(namespace) == -1) {
							intermediate.push(namespace)
						}
					}
					check(namespace)
					while (path.length > 0) {
						namespace += '.' + path.shift()
						check(namespace)
					}
				}

				for (path in intermediate) {
					var m = Node.TModule(path.split('.'), [])
					namespaces[path] = m
				}
			}

			function findBasicType(name: String) {
				let subj = findInNamespaceRoots(name)
				if (subj == null)
					throw fail('Cannot find basic type `\(name)`. This type should be a part of standard library of the compilation target.')
				switch (subj) {
					case Node.TDeclare(_, t):
						let node = registerClassType(t)
						return node
				}
				return registerClassType(subj)
			}

			typeInt = findBasicType('Int').instantiate()
			typeBool = findBasicType('Bool').instantiate()
			typeFloat = findBasicType('Float').instantiate()
			typeString = findBasicType('String').instantiate()
			typeArray = findBasicType('Array').instantiate()
			typeMap = findBasicType('Map').instantiate()
			typeAny = findBasicType('Any').instantiate()
			typeVoid = findBasicType('Void').instantiate()

			// Fill module scopes of all files at first
			pushScope()
			for (file in collected) for (e in file) switch (e) {
				case Node.TModule(path, el):
					for (node in el) {
						parents.set(node, e)
						fill(node)
					}
				case _:
			}
			popScope()

			// Fill initialization code at files roots
			for (file in collected) {
				pushScope()
				for (e in file) switch (e) {
					case Node.TModule(path, el):
					case _: fill(e)
				}
				popScope()
			}
		}

		function registerClassType(node: Node): Type {
		}

		function registerEnumType(node: Node): Type {
		}

		static let never = '. This should never happen. Probably incomplete feature was used. Ping a compiler developer with a code sample.'

		static function fail(msg: String, node: Node = null) {
			var data = Project.data.get(node)
			if (data == null) {
				throw new CompilerError(Fail.TyperError, msg, 0, 0, "")
			}
			throw new CompilerError(Fail.TyperError, msg, data.line, data.column, data.fileName)
		}

		function nameOfModuleItem(node: Node): String {
			switch (node) {
				case Node.TVar(name, _): return name
				case Node.TFunction(name, _):
					if (let named = name) return named
					else throw 'Module function should have a name'
				case Node.TPrivate(node): switch (node) {
					case Node.TClass(t, _): switch (t) {
						case NodeType.Type(name): return name
						case NodeType.ParametricType(name): return name
					}
				}
				case Node.TClass(t, _): switch (t) {
					case NodeType.Type(name): return name
					case NodeType.ParametricType(name): return name
				}
				case Node.TEnum(t, _): switch (t) {
					case NodeType.Type(name): return name
					case NodeType.ParametricType(name): return name
				}
				case Node.TDeclare(name, _): return name
				case _: throw 'Improper module item format ' + TestParser.stringify(node)
			}
		}

		function findInNamespaceRoots(name: String): Node {
			if (namespaces[name] != null) return namespaces[name]
			var m = namespaces['']
			var el = null
			switch (m) {
				case Node.TModule(_, els): el = els
				case _: return null // No root
			}
			for (e in el) if (name == nameOfModuleItem(e)) return e
			return null
		}

		// Scopes
		private let scopes: [[String : Node]] = [[:]]
		let parents: [Node : Node] = [:]
		private function pushScope() scopes.push(([:]))
		private function popScope() scopes.pop()
		private function addScope(name, node) scopes[scopes.length - 1].set(name, node)

		// Types
		private let types: [String : Type] = [:]
		private var typeString: Type? = null
		private var typeInt: Type? = null
		private var typeFloat: Type? = null
		private var typeBool: Type? = null
		private var typeArray: Type? = null // Type instantiators
		private var typeMap: Type? = null // Type instantiators
		private var typeAny: Type? = null
		private var typeVoid: Type? = null
		private var namespaces: [String : Node] = [:]

		// Stack
		var insideFunction = false // `function () { insideFunction }`

		function findType(name: String): Node? {
			for (i in scopes.length) {
				if (let subj = scopes[scopes.length - i - 1].get(name)) {
					return subj
				}
			}
			return findInNamespaceRoots(name)
		}

		// Syntax tree traverse
		private function fill(node: Node): Void {
			switch (node) {
				// Types
				case Node.TClass(t, extend, implement, f, external):
					addScope(DataHelper.extractTypeName(t), node)
					registerClassType(node)

				case Node.TEnum(t, f, valuesType):
					addScope(DataHelper.extractTypeName(t), node)
					registerEnumType(node)

				case Node.TDeclare(name, vnode):
					switch (vnode) {
						case Node.TClass(_):
							addScope(name, vnode)
							registerClassType(vnode)
						case Node.TFunction(name, _):
							addScope(name, vnode)
						case Node.TVar(name, t, _):
							addScope(name, vnode)
					}

				// Statements do not return value
				case Node.TVars(e):
					for (ee in e) fill(ee)
				case Node.TBlock(el):
					pushScope()
					for (e in el) fill(e)
					popScope()
				case Node.TVar(name, t, e, const):
					if (e == null, const)
						throw fail('Constant should have a value `let \(name) = value`', node)
					if (e != null) {
						pushScope()
						fillExpression(e)
						popScope()
					}
					addScope(name, node)


				case Node.TAssignop(a, op, b):
					fill(a)
					var parent: Node = parents.get(a)
					switch (parent) {
						case Node.TVar(name, _, _, const):
							if (const)
							throw fail('Cannot reassign a constant `\(name)`', node)
						case Node.TFunction(name, _):
							throw fail('Cannot reassign a function `\(name)`', node)
						case _: // Ok
					}
					fillExpression(b)

				case Node.TBinop(a, op, b):
					fillExpression(a)
					fillExpression(b)

					var parent: Node = parents.get(a)
					if (op == Token.OpAssign) switch (parent) {
						case null:
							throw fail('No parent node for `\(a)`', node)
						case Node.TVar(name, _, _, const):
							if (const)
								throw fail('Cannot reassign a constant `\(name)`', node)
						case Node.TIdent(name):
							throw fail('Cannot reassign case parameter `\(name)`', node)
						case Node.TFunction(name, _):
							throw fail('Cannot reassign a function `\(name)`', node)
						case _: // Ok
					}
				case Node.TBreak:

				case Node.TFor(name, over, by):
					pushScope()
					fillExpression(over)
					addScope(name, node)
					fill(by)
					popScope()

				case Node.TFunction(name, expr, vars, rettype):
					addScope(name, node)

					// Save stack
					let _insideFunction = insideFunction
					// Reset stack
					insideFunction = true
					pushScope()
					if (expr != null) fill(expr)
					popScope()

					// Restore stack
					insideFunction = _insideFunction

				case Node.TIf(econd, eif, eelse):
					var depth = 0
					for (e in econd) {
						switch (e) {
							case Node.TVar(_, t, _, const):
								if (!const)
									throw fail('Only if-let bindings supported', node)
								if (t != null)
									throw fail('Do not specify a type in if-let bindings', node)
								depth++
								pushScope()
								fill(e)
							case _:
								fillExpression(e)
						}
					}
					fill(eif)
					while (depth > 0) {
						depth--
						popScope()
					}

					if (eelse != null) fill(eelse)

				case Node.TReturn(e):
					if (!insideFunction)
						throw fail('Cannot use `return` outside of function', node)
					if (e != null) fillExpression(e)
				case Node.TSwitch(exprs, conds, guards, cases):
					for (e in exprs) { pushScope() fill(e) popScope() }

					var i = 0
					while (i < cases.length) {
						pushScope()
						var e = conds[i]
						// Fill case condition
						function follow(e: Node) {
							switch (e) {
								case Node.TDot(ex, name):
									fillExpression(e)
								case Node.TDotUpper(ex, name):
									fillExpression(e)
								case Node.TParenthesis(e): {fill(e)}
								case Node.TUnderscore: {}
								case Node.TNull: {}
								case Node.TBool(_): {}
								case Node.TInt(_): {}
								case Node.TString(_): {}
								case Node.TCall(ex, args, argNames): {
									follow(ex)
									for (ee in args) follow(ee)
								}
								case Node.TIdent(name): // bind var
								{
									if (name.charAt(0) == name.charAt(0).toUpperCase()) {fill(e)}
									else {
										addScope(name, e)
									}
								}
								case Node.TBinop(a, op, b):
								if (op == Token.OpOr) {follow(a) follow(b)}
								else throw fail('' + e, e)
								case Node.TIf(econd, _, _):
									pushScope()
									fill(econd[0])
									popScope()
								case _:
									throw fail('' + e, e)
							}
						}
						follow(e)
						// Fill case result expression
						var e = cases[i]
						pushScope() fill(e) popScope()
						popScope()
						i++
					}
				case Node.TThrow(e):
					fillExpression(e)
				case Node.TTry(e, t, v, ca):
					fill(e)
				case Node.TWhile(econd, e, pre):
					fillExpression(econd)
					fill(e)
				case Node.TIs(expr, t):
					fillExpression(expr)

				case Node.TContinue:

				// Expressions and errors
				case _:
					fillExpression(node)
			}
		}


		// Expressions return values
		function fillExpression(node) {
			switch (node) {
				case Node.TIdent(name):
					var subj = null
					for (i in scopes.length) {
						subj = scopes[scopes.length - i - 1].get(name)
						if (subj != null) {
							break
						}
					}

					if (subj == null) subj = findInNamespaceRoots(name)
					if (subj == null)
						throw fail('Cannot find parent by name `\(name)` for \(node)', node)
					if (parents.get(node) != null, parents.get(node) != subj)
						throw fail('Parent overwitten from \(parents.get(node)) to \(subj) for node \(node)' + never, node)
					parents.set(node, subj)

				case Node.TArrow(expr, vars, rettype):
					pushScope()
					// Save stack
					let _insideFunction = insideFunction

					// Reset stack
					insideFunction = true
					fillExpression(expr)
					popScope()

					// Restore stack
					insideFunction = _insideFunction

				case Node.TFunction(name, expr, vars, rettype):
					pushScope()
					addScope(name, node)

					// Save stack
					let _insideFunction = insideFunction

					// Reset stack
					insideFunction = true

					if (expr != null) fill(expr)
					popScope()

					// Restore stack
					insideFunction = _insideFunction

				case Node.TArray(el):
					switch (el[0]) {
						case Node.TFor(name, over, by):
							if (el.length > 1)
								throw fail('Cannot use loop `for` within array of more than one element `[for(), ...]`', el[1])

							pushScope()
							fillExpression(over)
							addScope(name, el[0])
							fillExpression(by)
							popScope()
						case _:
							for (e in el) fillExpression(e)
					}

				case Node.TMap(keys, values):
					for (i in keys.length) {
						fillExpression(keys[i])
						fillExpression(values[i])
					}
				case Node.TAs(e, kind, t):
					fillExpression(e)

				case Node.TBlock(el):
					if (el.length == 0)
						throw fail('Cannot use empty block `{}` as a value', node)
					pushScope()
					for (i in el.length) if (i < el.length - 1) {
						fill(el[i])
					}
					let latest = el[el.length - 1]
					fillExpression(latest)
					popScope()

				case Node.TDot(e, n):
					fillExpression(e)

				case Node.TDotUpper(e, n):
					fillExpression(e)

				case Node.NodeTypeValue(t): switch (t) {
					case NodeType.Type(name):
						var subj = null
						for (i in scopes.length) {
							subj = scopes[scopes.length - i - 1].get(name)
							if (subj != null) {
								break
							}
						}
						if (subj == null) subj = findInNamespaceRoots(name)
						if (subj == null)
							throw fail('Cannot find type by name `\(name)` for \(node)', node)
						if (parents.get(node) != null, parents.get(node) != subj)
							throw fail('Parent overwitten from \(parents.get(node)) to \(subj) for node \(node)' + never, node)
						parents.set(node, subj)
					case NodeType.ParametricType(name, _):
						throw fail('Cannot use generic type `\(name)` as a value', node)
					case _:
						throw fail('Cannot use this type as a value', node)
				}

				case Node.TNew(path, t, el, names, values):
					for (e in el) fillExpression(e)

				case Node.TObject(names, el):
					for (e in el) fillExpression(e)

				case Node.TTry(e, t, v, ca):
					fillExpression(e)

				case Node.TIf(econd, eif, eelse):
					fillExpression(econd[0])
					fillExpression(eif)
					fillExpression(eelse)

				// Simple nodes
				case Node.TNull:

				case Node.TString(_):

				case Node.TBool(_):

				case Node.TInt(_):

				case Node.TFloat(_):

				case Node.TParenthesis(e):
					fillExpression(e)

				case Node.TElvis(a, b):
					fillExpression(a)
					fillExpression(b)

				case Node.TCall(e, el, elNames):
					for (e in el) fillExpression(e)
				 	fillExpression(e) // JavaScript evaluates arguments first

				case Node.TBinop(a, op, b):
					fill(a)
					fillExpression(b)

				case Node.TUnop(_, _, e):
					fillExpression(e)

				case Node.TIndex(e, i):
					fillExpression(e)
					fillExpression(i)

				case Node.TAssignop(a, op, b):
					fillExpression(a)
					var parent: Node = parents.get(a)
					switch (parent) {
						case Node.TVar(name, _, _, const):
							if (const)
							throw fail('Cannot reassign a constant `\(name)`', node)
						case Node.TFunction(name, _):
							throw fail('Cannot reassign a function `\(name)`', node)
						case _: // Ok
					}
					fillExpression(b)

				case Node.TThis:

				// Errors
				case Node.TUnderscore:
					throw fail('Cannot use underscore `_` outside of case pattern', node)
				case Node.TExport(_):
					throw fail('Cannot use `export` here: only applicable to module declarations', node)
				case Node.TStatic(_):
					throw fail('Cannot use `static` here: only applicable to class fields', node)
				case Node.TPrivate(_):
					throw fail('Cannot use `private` here: only applicable to class fields and module declarations', node)
				case Node.TModule(_):
					throw fail('Modules should be at a file\' upper scope', node)

				// Not expressions
				case Node.TBreak:
					throw fail('Cannot use `break` as a value', node)
				case Node.TContinue:
					throw fail('Cannot use `continue` as a value', node)
				case Node.TClass(_):
					throw fail('Cannot use `class` as a value', node)
				case Node.TEnum(_):
					throw fail('Cannot use `enum` as a value', node)
				case Node.TDeclare(_):
					throw fail('Cannot use `declare` as a value', node)
				case Node.TVar(_):
					throw fail('Cannot use `var` as a value', node)
				case Node.TSwitch(_):
					throw fail('Cannot use `switch` as a value', node)
				case Node.TFor(_):
					throw fail('Cannot use `for` as a value. To build array from loop, surround with `[for()]` brackets.', node)

				// Fails
				case null:
					throw fail('Got null node' + never, node)
				case _:
					throw fail('Unknown node expression kind to type ' + node + never, node)
			}
		}
	}

	enum Type {
	}

	class ClassType {
	}
}
