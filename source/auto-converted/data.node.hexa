module data {
	enum Node {
		TString(s:String)
		TIdent(s:String)
		TBool(b:Bool)
		TThis
		TSuper
		TInt(s:String)
		TFloat(s:String)
		TNull
		TBinop(op:Token, a:data.Node, b:data.Node)
		TBlock(el:[data.Node])
		TCall(e:data.Node, args:[data.Node], argNames:[String])
		TIf(econd:[data.Node], eif:data.Node, eelse:data.Node?)
		TParenthesis(inner:data.Node)
		TReturn(e:data.Node?)
		TThrow(e:data.Node)
		TBreak
		TContinue
		TUnop(op:Token, postfix:Bool, e:data.Node)
		TWhile(econd:data.Node, e:data.Node, pre:Bool)
		TFunction(name:String, expr:data.Node, vars:[data.Node], rettype:data.NodeType)
		TVar(name:String, t:data.NodeType, expr:data.Node, const:Bool)
		TVars(vars:[data.Node])
		TClass(t:data.NodeType, ext:data.NodeType, impl:[data.NodeType], fields:[data.Node], external:Bool)
		TTry(expr:data.Node, t:[data.NodeType], v:[data.Node], catches:[data.Node])
		TDot(expr:data.Node, name:String)
		TNew(t:data.NodeType, args:[data.Node], fields:[String], el:[data.Node])
		TArray(elements:[data.Node])
		TMap(keys:[data.Node], values:[data.Node])
		TIndex(expr:data.Node, index:data.Node)
		TSwitch(exprs:[data.Node], conds:[[data.Node]], cases:[data.Node])
		TModule(path:[String], el:[data.Node])
		TObject(names:[String], el:[data.Node])
		TEnum(t:data.NodeType, fields:[data.Node])
		TEnumExtract(expr:data.Node, extract:[String], name:String)
		TType(name:String, t:data.NodeType)
		TDeclare(name:String, t:data.Node)
		TUsing(path:[String])
		TIs(expr:data.Node, t:data.NodeType)
		TAs(expr:data.Node, kind:Token, t:data.NodeType)
		TUnderscore
		TStatic(field:data.Node)
		TFor(name:String, over:data.Node, by:data.Node)
		TElvis(nullable:data.Node, othewise:data.Node)
		NodeTypeValue(kind:data.NodeType)
	}
}
