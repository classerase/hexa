module {
	@coreApi
	class Type {
		static function getClass(o: kind.T): Class< kind.T > {
			if(o == null) return null else return js.boot.Boot.getClass(o)
		}

		@has_untyped
		static function getEnum(o: EnumValue): Enum< Any > {
			if(o == null) return null
			return o.__enum__
		}

		@has_untyped
		static function getSuperClass(c: Class< Any >): Class< Any > {
			return c.__super__
		}

		@has_untyped
		static function getClassName(c: Class< Any >): String {
			var a: [String] = c.__name__
			if(a == null) return null
			return a.join('.')
		}

		@has_untyped
		static function getEnumName(e: Enum< Any >): String {
			var a: [String] = e.__ename__
			return a.join('.')
		}

		@has_untyped
		static function resolveClass(name: String): Class< Any > {
			var cl: Class< Any > = _hxClasses[name]
			if(cl == null || !__define_feature__('js.Boot.isClass', cl.__name__)) return null
			return cl
		}

		@has_untyped
		static function resolveEnum(name: String): Enum< Any > {
			var e: Any = _hxClasses[name]
			if(e == null || !__define_feature__('js.Boot.isEnum', e.__ename__)) return null
			return e
		}

		@has_untyped
		static function createInstance(cl: Class< kind.T >, args: [Any]): kind.T {
			var _g: Int = args.length
			switch (_g) {
				case 0: return __new__(cl)

				case 1: return __new__(cl, args[0])

				case 2: return __new__(cl, args[0], args[1])

				case 3: return __new__(cl, args[0], args[1], args[2])

				case 4: return __new__(cl, args[0], args[1], args[2], args[3])

				case 5: return __new__(cl, args[0], args[1], args[2], args[3], args[4])

				case 6: return __new__(cl, args[0], args[1], args[2], args[3], args[4], args[5])

				case 7: return __new__(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6])

				case 8: return __new__(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7])

				case 9: return __new__(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8])

				case 10: return __new__(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9])

				case 11: return __new__(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10])

				case 12: return __new__(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11])

				case 13: return __new__(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12])

				case 14: return __new__(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13])
				
				case _: throw new HaxeError('Too many arguments')
			}
		}

		@has_untyped
		static function createEmptyInstance(cl: Class< kind.T >): kind.T {
			__js__('function empty() {}; empty.prototype = cl.prototype')
			return __js__('new empty()')
		}

		static function createEnum(e: Enum< kind.T >, constr: String, params?: [Any]?): kind.T {
			var f: Any = Reflect.field(e, constr)
			if(f == null) throw new HaxeError('No such constructor ' + constr)
			if(Reflect.isFunction(f)) {
				if(params == null) throw new HaxeError('Constructor ' + constr + ' need parameters')
				return ((f as! haxe.constraints.Function).apply(e, params) as! Any)
			}
			if(params != null && params.length != 0) throw new HaxeError('Constructor ' + constr + ' does not need parameters')
			return f
		}

		@has_untyped
		static function createEnumIndex(e: Enum< kind.T >, index: Int, params?: [Any]?): kind.T {
			var c: String = e.__constructs__[index]
			if(c == null) throw new HaxeError(index + ' is not a valid enum constructor index')
			return Type.createEnum(e, c, params)
		}

		@has_untyped
		static function getInstanceFields(c: Class< Any >): [String] {
			var a: [String] = {[]}
			__js__('for(var i in c.prototype) a.push(i)')
			HxOverrides.remove(a, '__class__')
			HxOverrides.remove(a, '__properties__')
			return a
		}

		static function getClassFields(c: Class< Any >): [String] {
			var a: [String] = Reflect.fields(c)
			HxOverrides.remove(a, '__name__')
			HxOverrides.remove(a, '__interfaces__')
			HxOverrides.remove(a, '__properties__')
			HxOverrides.remove(a, '__super__')
			HxOverrides.remove(a, '__meta__')
			HxOverrides.remove(a, 'prototype')
			return a
		}

		static function getEnumConstructs(e: Enum< Any >): [String] {
			return ((e as! {__constructs__: [String]}).__constructs__ as! [String]).slice()
		}

		@has_untyped
		static function typeof(v: Any): kind.ValueType {
			var _g: String = __js__('typeof')(v)
			switch (_g) {
				case 'boolean': return kind.ValueType.TBool

				case 'function': {
					if(__define_feature__('js.Boot.isClass', v.__name__) || __define_feature__('js.Boot.isEnum', v.__ename__)) return kind.ValueType.TObject
					return kind.ValueType.TFunction
				}

				case 'number': {
					if(Math.ceil(v) == v % 2147483648.0) return kind.ValueType.TInt
					return kind.ValueType.TFloat
				}

				case 'object': {
					if(v == null) return kind.ValueType.TNull
					var e: Enum< Any > = v.__enum__
					if(e != null) return kind.ValueType.TEnum(e)
					var c: Class< Any > = js.boot.Boot.getClass(v)
					if(c != null) return kind.ValueType.TClass(c)
					return kind.ValueType.TObject
				}

				case 'string': return kind.ValueType.TClass(String)

				case 'undefined': return kind.ValueType.TNull
				
				case _: return kind.ValueType.TUnknown
			}
		}

		@has_untyped
		static function enumEq(a: kind.T, b: kind.T): Bool {
			if(a == b) return true
			try {
				if(a[0] != b[0]) return false
				{
					var _g1: Int = 2
					var _g: Int = a.length
					while(_g1 < _g) {
						var i: Int = _g1++
						if(!Type.enumEq(a[i], b[i])) return false
					}
				}
				var e: Any = a.__enum__
				if(e != b.__enum__ || e == null) return false
			} catch(e1:Any) {
				return false
			}
			return true
		}

		@has_untyped
		static function enumConstructor(e: EnumValue): String {
			return e[0]
		}

		@has_untyped
		static function enumParameters(e: EnumValue): [Any] {
			return e.slice(2)
		}

		@has_untyped
		static function enumIndex(e: EnumValue): Int {
			return e[1]
		}

		@has_untyped
		static function allEnums(e: Enum< kind.T >): [kind.T] {
			return __define_feature__('Type.allEnums', e.__empty_constructs__)
		}

	}
}
