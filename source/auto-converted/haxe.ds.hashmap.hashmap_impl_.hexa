module haxe.ds.hashmap {
	@final
	private class HashMap_Impl_ {
		@impl
		static function _new(): haxe.ds.hashmap.HashMap< haxe.ds.hashmap.K, haxe.ds.hashmap.V > {
			var this1: haxe.ds.hashmap.HashMapData< haxe.ds.hashmap.K, haxe.ds.hashmap.V > = new HashMapData< haxe.ds.hashmap.K, haxe.ds.hashmap.V >()
			return (this1 as! haxe.ds.hashmap.HashMap< haxe.ds.hashmap.K, haxe.ds.hashmap.V >)
		}

		@impl
		static function set(this1: haxe.ds.hashmap.HashMapData< haxe.ds.hashmap.K, haxe.ds.hashmap.V >, k: haxe.ds.hashmap.K, v: haxe.ds.hashmap.V): Void {
			{
				var _this: haxe.ds.intmap.IntMap< haxe.ds.hashmap.K > = this1.keys
				var key: Int = k.hashCode()
				_this.h[key] = k
			}
			{
				var _this1: haxe.ds.intmap.IntMap< haxe.ds.hashmap.V > = this1.values
				var key1: Int = k.hashCode()
				_this1.h[key1] = v
			}
		}

		@impl
		static function get(this1: haxe.ds.hashmap.HashMapData< haxe.ds.hashmap.K, haxe.ds.hashmap.V >, k: haxe.ds.hashmap.K): haxe.ds.hashmap.V? {
			var _this: haxe.ds.intmap.IntMap< haxe.ds.hashmap.V > = this1.values
			var key: Int = k.hashCode()
			return _this.h[key]
		}

		@impl
		static function exists(this1: haxe.ds.hashmap.HashMapData< haxe.ds.hashmap.K, haxe.ds.hashmap.V >, k: haxe.ds.hashmap.K): Bool {
			var _this: haxe.ds.intmap.IntMap< haxe.ds.hashmap.V > = this1.values
			var key: Int = k.hashCode()
			return _this.h.hasOwnProperty(key)
		}

		@impl
		static function remove(this1: haxe.ds.hashmap.HashMapData< haxe.ds.hashmap.K, haxe.ds.hashmap.V >, k: haxe.ds.hashmap.K): Bool {
			this1.values.remove(k.hashCode())
			return this1.keys.remove(k.hashCode())
		}

		@impl
		static function keys(this1: haxe.ds.hashmap.HashMapData< haxe.ds.hashmap.K, haxe.ds.hashmap.V >): stdtypes.Iterator< haxe.ds.hashmap.K > {
			return this1.keys.iterator()
		}

		@impl
		static function iterator(this1: haxe.ds.hashmap.HashMapData< haxe.ds.hashmap.K, haxe.ds.hashmap.V >): stdtypes.Iterator< haxe.ds.hashmap.V > {
			return this1.values.iterator()
		}

	}
}
