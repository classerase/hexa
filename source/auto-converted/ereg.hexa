module {
	@coreApi
	class EReg {
		private var r: ereg.HaxeRegExp
		function match(s: String): Bool {
			if(this.r.global) this.r.lastIndex = 0
			this.r.m = this.r.exec(s)
			this.r.s = s
			return this.r.m != null
		}

		function matched(n: Int): String {
			if(this.r.m != null && n >= 0 && n < this.r.m.length) return this.r.m[n] else throw new HaxeError('EReg::matched')
		}

		function matchedLeft(): String {
			if(this.r.m == null) throw new HaxeError('No string matched')
			return HxOverrides.substr(this.r.s, 0, this.r.m.index)
		}

		function matchedRight(): String {
			if(this.r.m == null) throw new HaxeError('No string matched')
			var sz: Int = this.r.m.index + this.r.m[0].length
			return HxOverrides.substr(this.r.s, sz, this.r.s.length - sz)
		}

		function matchedPos(): {len: Int, pos: Int} {
			if(this.r.m == null) throw new HaxeError('No string matched')
			return {pos: this.r.m.index, len: this.r.m[0].length}
		}

		function matchSub(s: String, pos: Int, len?: Int): Bool {
			if(this.r.global) {
				this.r.lastIndex = pos
				var tmp: ereg.HaxeRegExp = this.r
				var tmp1: String = if(len < 0) s else HxOverrides.substr(s, 0, pos + len)
				this.r.m = tmp.exec(tmp1)
				var b: Bool = this.r.m != null
				if(b) this.r.s = s
				return b
			} else {
				var b1: Bool = this.match(if(len < 0) HxOverrides.substr(s, pos, null) else HxOverrides.substr(s, pos, len))
				if(b1) {
					this.r.s = s
					this.r.m.index += pos
				}
				return b1
			}
		}

		@has_untyped
		function split(s: String): [String] {
			var d: String = '#__delim__#'
			return s.replace(this.r, d).split(d)
		}

		@has_untyped
		function replace(s: String, by: String): String {
			return s.replace(this.r, by)
		}

		function map(s: String, f: EReg=>String): String {
			var offset: Int = 0
			var buf_b: String = ''
			while(true) {
				if(offset >= s.length) break else if(!this.matchSub(s, offset)) {
					buf_b += Std.string(HxOverrides.substr(s, offset, null))
					break
				}
				var p: {len: Int, pos: Int} = this.matchedPos()
				buf_b += Std.string(HxOverrides.substr(s, offset, p.pos - offset))
				buf_b += Std.string(f(this))
				if(p.len == 0) {
					buf_b += Std.string(HxOverrides.substr(s, p.pos, 1))
					offset = p.pos + 1
				} else offset = p.pos + p.len
				if(!this.r.global) break
			}
			if(!this.r.global && offset > 0 && offset < s.length) buf_b += Std.string(HxOverrides.substr(s, offset, null))
			return buf_b
		}

		new(r: String, opt: String) {
			this.r = new HaxeRegExp(r, opt.split('u').join(''))
		}
	}
}
