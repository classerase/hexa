module {
	class Lexer {
		static function tokenize(bytes: nodejs.Buffer< Int >, fileName: String): lexer.Tokens {
			var position: Int = 0
			var len: Int = bytes.length
			var to: Int = 0
			var s: String = ''
			var p: Int = 0
			var line: Int = 1
			var columnBase: Int = 0
			var params: [String] = new Array< String >()
			var tokens: nodejs.Buffer< Token > = nodejs.Buffer.alloc(len + 1)
			var lines: [Int] = {[]}
			var columns: [Int] = {[]}
			if(len > 2 && bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) position += 3
			while(position < len) {
				var _8: Int = 0
				while(true) {
					_8 = bytes[position]
					if(_8 == 10) {
						line++
						columnBase = position
					}
					if(!(_8 <= 32 && ++position < len)) break
				}
				if(position >= len) break
				var _16: Int = if(len - position > 1) _8 | bytes[position + 1] << 8 else _8
				if(_8 == 47) {
					if(_16 == 12079) {
						var pos: Int = position + 2
						while(bytes[position] != 10 && position < len) ++position
						continue
					}
					if(_16 == 10799 && bytes[position + 2] == 42) {
						position += 3
						p = position
						while(position < len) {
							var _32: Int = if(len - position > 3) bytes.readUInt32LE(position) else bytes[position]
							if((_32 & 255) == 10) {
								line++
								columnBase = position
							} else if((_32 & 16777215) == 3090986) break
							position++
						}
						if(position >= len) {
							var erline: Int?? = null
							var column: Int?? = null
							var filename: String?? = null
							if(erline != null) erline = erline else erline = line
							if(column != null) column = column else column = position - columnBase - 1
							if(filename != null) filename = filename else filename = fileName
							throw new HaxeError(new CompilerError(compilererror.Fail.LexerError, 'Unclosed doc-comment', erline, column, filename))
						}
						{
							params[to] = bytes.toString('utf8', p, position)
							{
								tokens[to++] = (65 as! Token)
								lines.push(line)
								columns.push(position - columnBase - 1)
							}
						}
						position += 3
						continue
					}
					if(_16 == 10799) {
						var pos1: Int = position + 2
						p = 0
						position += 2
						while(position < len) {
							if(len - position > 1) _16 = bytes.readUInt16LE(position) else _16 = bytes[position]
							if((_16 & 255) == 10) {
								line++
								columnBase = position
							} else if(_16 == 12074 && p > 0) --p else if(_16 == 10799) ++p else if(_16 == 12074 && p == 0) break
							position++
						}
						position += 2
						continue
					}
				}
				if((_8 & 95) >= 65 && (_8 & 95) <= 90 || _8 == 95) {
					var titlechar: Int = _8
					p = position + 1
					_8 = bytes[p]
					while(p < len && Lexer.isident[_8] != 0) _8 = bytes[++p]
					s = bytes.toString('ascii', position, p)
					var t: Token?
					if((_16 & 255) <= 90) t = null else {
						var _this: haxe.ds.stringmap.StringMap< Token > = ((Lexer.kwd as! map.IMap< String, Token >) as! haxe.ds.stringmap.StringMap< Token >)
						if(__js__('__map_reserved')[s] != null) t = _this.getReserved(s) else t = _this.h[(s as! Int)]
					}
					if(t != null) {
						tokens[to++] = t
						lines.push(line)
						columns.push(position - columnBase - 1)
					} else if(titlechar >= 65 && titlechar <= 90) {
						params[to] = s
						{
							tokens[to++] = (61 as! Token)
							lines.push(line)
							columns.push(position - columnBase - 1)
						}
					} else {
						params[to] = s
						{
							tokens[to++] = (62 as! Token)
							lines.push(line)
							columns.push(position - columnBase - 1)
						}
					}
					position = p
					continue
				}
				if(_16 == 11822 && bytes[position + 2] == 46) {
					{
						tokens[to++] = (98 as! Token)
						lines.push(line)
						columns.push(position - columnBase - 1)
					}
					position += 3
					continue
				}
				if(_16 == 15934 && bytes[position + 2] == 62) {
					{
						tokens[to++] = (108 as! Token)
						lines.push(line)
						columns.push(position - columnBase - 1)
					}
					position += 3
					continue
				}
				var hash: Int = (_16 & 255) + ((_16 >> 8 & 255) << 3) & 239
				if(_16 == Lexer.op16token.readUInt16LE(hash * 2)) {
					{
						tokens[to++] = Lexer.op16token[hash + 512]
						lines.push(line)
						columns.push(position - columnBase - 1)
					}
					position += 2
					continue
				}
				var found: Token = Lexer.ops8a[_8]
				if(found != (0 as! Token)) {
					{
						tokens[to++] = found
						lines.push(line)
						columns.push(position - columnBase - 1)
					}
					position++
					continue
				}
				if(_8 < 40) {
					p = _8
					var pos2: Int = ++position
					while(bytes[position] != p && position < len) {
						if(bytes[position] == 10) {
							line++
							columnBase = position
						}
						if(bytes[position] == 92) {
							position += 2
							continue
						}
						if(len - position > 1) _16 = bytes.readUInt16LE(position) else _16 = bytes[position]
						position++
					}
					{
						params[to] = bytes.toString('utf8', pos2, position)
						{
							tokens[to++] = (64 as! Token)
							lines.push(line)
							columns.push(position - columnBase - 1)
						}
					}
					position++
					continue
				}
				if(_16 == 30768) {
					p = position
					p += 2
					_8 = bytes[position]
					while(_8 >= 65 && _8 <= 70 || _8 >= 48 && _8 <= 57 || _8 >= 97 && _8 <= 102) _8 = bytes[++p]
					if(p - position == 2) {
						var erline1: Int?? = null
						var column1: Int?? = null
						var filename1: String?? = null
						if(erline1 != null) erline1 = erline1 else erline1 = line
						if(column1 != null) column1 = column1 else column1 = position - columnBase - 1
						if(filename1 != null) filename1 = filename1 else filename1 = fileName
						throw new HaxeError(new CompilerError(compilererror.Fail.LexerError, 'Integer `0x` not allowed!', erline1, column1, filename1))
					}
					{
						params[to] = bytes.toString('ascii', position, p)
						{
							tokens[to++] = (63 as! Token)
							lines.push(line)
							columns.push(position - columnBase - 1)
						}
					}
					position = p
					continue
				}
				if(_8 < 58) {
					p = position
					_8 = bytes[p]
					var found1: Token = (63 as! Token)
					while(_8 >= 48 && _8 <= 57) _8 = bytes[++p]
					if(_8 == 46 && bytes[p + 1] != 46) {
						_8 = bytes[++p]
						while(_8 >= 48 && _8 <= 57) _8 = bytes[++p]
						found1 = (60 as! Token)
					}
					if(_8 == 101 || _8 == 69) {
						_8 = bytes[++p]
						if(_8 == 43 || _8 == 45) _8 = bytes[++p]
						while(_8 >= 48 && _8 <= 57) _8 = bytes[++p]
						found1 = (60 as! Token)
					}
					{
						params[to] = bytes.toString('ascii', position, p)
						{
							tokens[to++] = found1
							lines.push(line)
							columns.push(position - columnBase - 1)
						}
					}
					position = p
					continue
				}
				if(position >= len) break
				var message: String = 'Unexpected character ' + String.fromCharCode(_8)
				var erline2: Int?? = null
				var column2: Int?? = null
				var filename2: String?? = null
				if(erline2 != null) erline2 = erline2 else erline2 = line
				if(column2 != null) column2 = column2 else column2 = position - columnBase - 1
				if(filename2 != null) filename2 = filename2 else filename2 = fileName
				throw new HaxeError(new CompilerError(compilererror.Fail.LexerError, message, erline2, column2, filename2))
			}
			return new Tokens(tokens, to, params, lines, columns, fileName)
		}

		static function init(): Void {
			Lexer.isident = nodejs.Buffer.alloc(256)
			{
				var _g: Int = 0
				while(_g < 256) {
					var _8: Int = _g++
					Lexer.isident[_8] = if(_8 >= 65 && _8 <= 90 || _8 >= 48 && _8 <= 57 || _8 >= 97 && _8 <= 122 || _8 == 95) 128 else 0
				}
			}
			Lexer.isUpper = nodejs.Buffer.alloc(256)
			{
				var _g1: Int = 0
				while(_g1 < 256) {
					var _81: Int = _g1++
					Lexer.isident[_81] = if(_81 >= 65 && _81 <= 90 || _81 >= 48 && _81 <= 57 || _81 >= 97 && _81 <= 122 || _81 == 95) 128 else 0
				}
			}
			Lexer.isident = nodejs.Buffer.alloc(256)
			{
				var _g2: Int = 0
				while(_g2 < 256) {
					var _82: Int = _g2++
					Lexer.isident[_82] = if(_82 >= 65 && _82 <= 90 || _82 >= 48 && _82 <= 57 || _82 >= 97 && _82 <= 122 || _82 == 95) 128 else 0
				}
			}
			var _g3: [String:Token] = new StringMap< Token >()
			{
				var value: Token = (1 as! Token)
				if(__js__('__map_reserved')['_'] != null) _g3.setReserved('_', value) else _g3.h[('_' as! Int)] = value
			}
			{
				var value1: Token = (58 as! Token)
				if(__js__('__map_reserved')['as'] != null) _g3.setReserved('as', value1) else _g3.h[('as' as! Int)] = value1
			}
			{
				var value2: Token = (3 as! Token)
				if(__js__('__map_reserved')['break'] != null) _g3.setReserved('break', value2) else _g3.h[('break' as! Int)] = value2
			}
			{
				var value3: Token = (4 as! Token)
				if(__js__('__map_reserved')['case'] != null) _g3.setReserved('case', value3) else _g3.h[('case' as! Int)] = value3
			}
			{
				var value4: Token = (6 as! Token)
				if(__js__('__map_reserved')['catch'] != null) _g3.setReserved('catch', value4) else _g3.h[('catch' as! Int)] = value4
			}
			{
				var value5: Token = (7 as! Token)
				if(__js__('__map_reserved')['class'] != null) _g3.setReserved('class', value5) else _g3.h[('class' as! Int)] = value5
			}
			{
				var value6: Token = (8 as! Token)
				if(__js__('__map_reserved')['continue'] != null) _g3.setReserved('continue', value6) else _g3.h[('continue' as! Int)] = value6
			}
			{
				var value7: Token = (9 as! Token)
				if(__js__('__map_reserved')['do'] != null) _g3.setReserved('do', value7) else _g3.h[('do' as! Int)] = value7
			}
			{
				var value8: Token = (10 as! Token)
				if(__js__('__map_reserved')['else'] != null) _g3.setReserved('else', value8) else _g3.h[('else' as! Int)] = value8
			}
			{
				var value9: Token = (11 as! Token)
				if(__js__('__map_reserved')['enum'] != null) _g3.setReserved('enum', value9) else _g3.h[('enum' as! Int)] = value9
			}
			{
				var value10: Token = (12 as! Token)
				if(__js__('__map_reserved')['extends'] != null) _g3.setReserved('extends', value10) else _g3.h[('extends' as! Int)] = value10
			}
			{
				var value11: Token = (13 as! Token)
				if(__js__('__map_reserved')['declare'] != null) _g3.setReserved('declare', value11) else _g3.h[('declare' as! Int)] = value11
			}
			{
				var value12: Token = (14 as! Token)
				if(__js__('__map_reserved')['false'] != null) _g3.setReserved('false', value12) else _g3.h[('false' as! Int)] = value12
			}
			{
				var value13: Token = (15 as! Token)
				if(__js__('__map_reserved')['for'] != null) _g3.setReserved('for', value13) else _g3.h[('for' as! Int)] = value13
			}
			{
				var value14: Token = (16 as! Token)
				if(__js__('__map_reserved')['function'] != null) _g3.setReserved('function', value14) else _g3.h[('function' as! Int)] = value14
			}
			{
				var value15: Token = (17 as! Token)
				if(__js__('__map_reserved')['if'] != null) _g3.setReserved('if', value15) else _g3.h[('if' as! Int)] = value15
			}
			{
				var value16: Token = (18 as! Token)
				if(__js__('__map_reserved')['implements'] != null) _g3.setReserved('implements', value16) else _g3.h[('implements' as! Int)] = value16
			}
			{
				var value17: Token = (19 as! Token)
				if(__js__('__map_reserved')['import'] != null) _g3.setReserved('import', value17) else _g3.h[('import' as! Int)] = value17
			}
			{
				var value18: Token = (20 as! Token)
				if(__js__('__map_reserved')['in'] != null) _g3.setReserved('in', value18) else _g3.h[('in' as! Int)] = value18
			}
			{
				var value19: Token = (22 as! Token)
				if(__js__('__map_reserved')['interface'] != null) _g3.setReserved('interface', value19) else _g3.h[('interface' as! Int)] = value19
			}
			{
				var value20: Token = (23 as! Token)
				if(__js__('__map_reserved')['let'] != null) _g3.setReserved('let', value20) else _g3.h[('let' as! Int)] = value20
			}
			{
				var value21: Token = (25 as! Token)
				if(__js__('__map_reserved')['new'] != null) _g3.setReserved('new', value21) else _g3.h[('new' as! Int)] = value21
			}
			{
				var value22: Token = (26 as! Token)
				if(__js__('__map_reserved')['null'] != null) _g3.setReserved('null', value22) else _g3.h[('null' as! Int)] = value22
			}
			{
				var value23: Token = (28 as! Token)
				if(__js__('__map_reserved')['module'] != null) _g3.setReserved('module', value23) else _g3.h[('module' as! Int)] = value23
			}
			{
				var value24: Token = (29 as! Token)
				if(__js__('__map_reserved')['private'] != null) _g3.setReserved('private', value24) else _g3.h[('private' as! Int)] = value24
			}
			{
				var value25: Token = (31 as! Token)
				if(__js__('__map_reserved')['return'] != null) _g3.setReserved('return', value25) else _g3.h[('return' as! Int)] = value25
			}
			{
				var value26: Token = (32 as! Token)
				if(__js__('__map_reserved')['static'] != null) _g3.setReserved('static', value26) else _g3.h[('static' as! Int)] = value26
			}
			{
				var value27: Token = (59 as! Token)
				if(__js__('__map_reserved')['super'] != null) _g3.setReserved('super', value27) else _g3.h[('super' as! Int)] = value27
			}
			{
				var value28: Token = (33 as! Token)
				if(__js__('__map_reserved')['switch'] != null) _g3.setReserved('switch', value28) else _g3.h[('switch' as! Int)] = value28
			}
			{
				var value29: Token = (34 as! Token)
				if(__js__('__map_reserved')['this'] != null) _g3.setReserved('this', value29) else _g3.h[('this' as! Int)] = value29
			}
			{
				var value30: Token = (35 as! Token)
				if(__js__('__map_reserved')['throw'] != null) _g3.setReserved('throw', value30) else _g3.h[('throw' as! Int)] = value30
			}
			{
				var value31: Token = (36 as! Token)
				if(__js__('__map_reserved')['true'] != null) _g3.setReserved('true', value31) else _g3.h[('true' as! Int)] = value31
			}
			{
				var value32: Token = (37 as! Token)
				if(__js__('__map_reserved')['try'] != null) _g3.setReserved('try', value32) else _g3.h[('try' as! Int)] = value32
			}
			{
				var value33: Token = (39 as! Token)
				if(__js__('__map_reserved')['using'] != null) _g3.setReserved('using', value33) else _g3.h[('using' as! Int)] = value33
			}
			{
				var value34: Token = (40 as! Token)
				if(__js__('__map_reserved')['var'] != null) _g3.setReserved('var', value34) else _g3.h[('var' as! Int)] = value34
			}
			{
				var value35: Token = (41 as! Token)
				if(__js__('__map_reserved')['while'] != null) _g3.setReserved('while', value35) else _g3.h[('while' as! Int)] = value35
			}
			{
				var value36: Token = (57 as! Token)
				if(__js__('__map_reserved')['is'] != null) _g3.setReserved('is', value36) else _g3.h[('is' as! Int)] = value36
			}
			Lexer.kwd = _g3
			var _g11: [Int:Token] = new IntMap< Token >()
			_g11.h[64] = (70 as! Token)
			_g11.h[36] = (83 as! Token)
			_g11.h[35] = (78 as! Token)
			_g11.h[33] = (89 as! Token)
			_g11.h[37] = (101 as! Token)
			_g11.h[38] = (112 as! Token)
			_g11.h[40] = (80 as! Token)
			_g11.h[41] = (79 as! Token)
			_g11.h[42] = (102 as! Token)
			_g11.h[43] = (111 as! Token)
			_g11.h[44] = (75 as! Token)
			_g11.h[45] = (107 as! Token)
			_g11.h[46] = (77 as! Token)
			_g11.h[47] = (94 as! Token)
			_g11.h[58] = (76 as! Token)
			_g11.h[59] = (82 as! Token)
			_g11.h[60] = (99 as! Token)
			_g11.h[61] = (91 as! Token)
			_g11.h[62] = (96 as! Token)
			_g11.h[63] = (81 as! Token)
			_g11.h[91] = (72 as! Token)
			_g11.h[92] = (110 as! Token)
			_g11.h[93] = (71 as! Token)
			_g11.h[94] = (109 as! Token)
			_g11.h[123] = (74 as! Token)
			_g11.h[124] = (104 as! Token)
			_g11.h[125] = (73 as! Token)
			_g11.h[126] = (88 as! Token)
			var ops8: [Int:Token] = _g11
			Lexer.ops8a = nodejs.Buffer.alloc(256)
			{
				var key: stdtypes.Iterator< Int > = ops8.keys()
				while(key.hasNext()) {
					var key1: Int = key.next()
					Lexer.ops8a[key1] = ((ops8.h[key1] as! Token?) as! Token?)
				}
			}
			var _g21: [Int:Token] = new IntMap< Token >()
			_g21.h[11051] = (87 as! Token)
			_g21.h[11565] = (86 as! Token)
			_g21.h[15420] = (105 as! Token)
			_g21.h[15649] = (103 as! Token)
			_g21.h[15676] = (100 as! Token)
			_g21.h[15677] = (95 as! Token)
			_g21.h[15678] = (97 as! Token)
			_g21.h[15934] = (106 as! Token)
			_g21.h[31868] = (93 as! Token)
			_g21.h[9766] = (92 as! Token)
			_g21.h[15933] = (90 as! Token)
			_g21.h[11839] = (113 as! Token)
			var ops16: [Int:Token] = _g21
			{
				var key11: stdtypes.Iterator< Int > = ops16.keys()
				while(key11.hasNext()) {
					var key12: Int = key11.next()
					{
						var key2: stdtypes.Iterator< Int > = ops16.keys()
						while(key2.hasNext()) {
							var key21: Int = key2.next()
							if(key12 != key21 && ((key12 & 255) + ((key12 >> 8 & 255) << 3) & 239) == ((key21 & 255) + ((key21 >> 8 & 255) << 3) & 239)) throw new HaxeError(new CompilerError(compilererror.Fail.LexerError, '2-byte op hash collision: ' + key12 + ' ' + key21, 0, 0, 'INTERNAL'))
						}
					}
				}
			}
			Lexer.op16token = nodejs.Buffer.alloc(768)
			{
				var key3: stdtypes.Iterator< Int > = ops16.keys()
				while(key3.hasNext()) {
					var key4: Int = key3.next()
					var hash: Int = (key4 & 255) + ((key4 >> 8 & 255) << 3) & 239
					Lexer.op16token.writeUInt16LE(key4, hash * 2)
					Lexer.op16token[hash + 512] = ((ops16.h[key4] as! Token?) as! Token?)
				}
			}
			return {}
		}

		private static function simplehash(val: Int): Int {
			return (val & 255) + ((val >> 8 & 255) << 3) & 239
		}

		private static var isident: nodejs.Buffer< Int >
		private static var isUpper: nodejs.Buffer< Int >
		private static var isLower: nodejs.Buffer< Int >
		private static var ops8a: nodejs.Buffer< Token >
		private static var op16token: nodejs.Buffer< Token >
		private static var kwd: [String:Token]
	}
}
