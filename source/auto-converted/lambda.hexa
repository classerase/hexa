module {
	class Lambda {
		static function array(it: stdtypes.Iterable< lambda.A >): [lambda.A] {
			var a: [lambda.A] = new Array< lambda.A >()
			{
				var i: stdtypes.Iterator< lambda.A > = it.iterator()
				while(i.hasNext()) {
					var i1: lambda.A = i.next()
					a.push(i1)
				}
			}
			return a
		}

		static function list(it: stdtypes.Iterable< lambda.A >): List< lambda.A > {
			var l: List< lambda.A > = new List< lambda.A >()
			{
				var i: stdtypes.Iterator< lambda.A > = it.iterator()
				while(i.hasNext()) {
					var i1: lambda.A = i.next()
					l.add(i1)
				}
			}
			return l
		}

		static function map(it: stdtypes.Iterable< lambda.A >, f: lambda.A=>lambda.B): List< lambda.B > {
			var l: List< lambda.B > = new List< lambda.B >()
			{
				var x: stdtypes.Iterator< lambda.A > = it.iterator()
				while(x.hasNext()) {
					var x1: lambda.A = x.next()
					l.add(f(x1))
				}
			}
			return l
		}

		static function mapi(it: stdtypes.Iterable< lambda.A >, f: (Int, lambda.A)=>lambda.B): List< lambda.B > {
			var l: List< lambda.B > = new List< lambda.B >()
			var i: Int = 0
			{
				var x: stdtypes.Iterator< lambda.A > = it.iterator()
				while(x.hasNext()) {
					var x1: lambda.A = x.next()
					l.add(f(i++, x1))
				}
			}
			return l
		}

		static function flatten(it: stdtypes.Iterable< stdtypes.Iterable< lambda.A > >): List< lambda.A > {
			var l: List< lambda.A > = new List< lambda.A >()
			{
				var e: stdtypes.Iterator< stdtypes.Iterable< lambda.A > > = it.iterator()
				while(e.hasNext()) {
					var e1: stdtypes.Iterable< lambda.A > = e.next()
					{
						var x: stdtypes.Iterator< lambda.A > = e1.iterator()
						while(x.hasNext()) {
							var x1: lambda.A = x.next()
							l.add(x1)
						}
					}
				}
			}
			return l
		}

		static function flatMap(it: stdtypes.Iterable< lambda.A >, f: lambda.A=>stdtypes.Iterable< lambda.B >): List< lambda.B > {
			return Lambda.flatten(Lambda.map(it, f))
		}

		static function has(it: stdtypes.Iterable< lambda.A >, elt: lambda.A): Bool {
			{
				var x: stdtypes.Iterator< lambda.A > = it.iterator()
				while(x.hasNext()) {
					var x1: lambda.A = x.next()
					if(x1 == elt) return true
				}
			}
			return false
		}

		static function exists(it: stdtypes.Iterable< lambda.A >, f: lambda.A=>Bool): Bool {
			{
				var x: stdtypes.Iterator< lambda.A > = it.iterator()
				while(x.hasNext()) {
					var x1: lambda.A = x.next()
					if(f(x1)) return true
				}
			}
			return false
		}

		static function foreach(it: stdtypes.Iterable< lambda.A >, f: lambda.A=>Bool): Bool {
			{
				var x: stdtypes.Iterator< lambda.A > = it.iterator()
				while(x.hasNext()) {
					var x1: lambda.A = x.next()
					if(!f(x1)) return false
				}
			}
			return true
		}

		static function iter(it: stdtypes.Iterable< lambda.A >, f: lambda.A=>Void): Void {
			var x: stdtypes.Iterator< lambda.A > = it.iterator()
			while(x.hasNext()) {
				var x1: lambda.A = x.next()
				f(x1)
			}
		}

		static function filter(it: stdtypes.Iterable< lambda.A >, f: lambda.A=>Bool): List< lambda.A > {
			var l: List< lambda.A > = new List< lambda.A >()
			{
				var x: stdtypes.Iterator< lambda.A > = it.iterator()
				while(x.hasNext()) {
					var x1: lambda.A = x.next()
					if(f(x1)) l.add(x1)
				}
			}
			return l
		}

		static function fold(it: stdtypes.Iterable< lambda.A >, f: (lambda.A, lambda.B)=>lambda.B, first: lambda.B): lambda.B {
			{
				var x: stdtypes.Iterator< lambda.A > = it.iterator()
				while(x.hasNext()) {
					var x1: lambda.A = x.next()
					first = f(x1, first)
				}
			}
			return first
		}

		static function count(it: stdtypes.Iterable< lambda.A >, pred?: lambda.A=>Bool?): Int {
			var n: Int = 0
			if(pred == null) {
				var _: stdtypes.Iterator< lambda.A > = it.iterator()
				while(_.hasNext()) {
					var _1: lambda.A = _.next()
					n++
				}
			} else {
				var x: stdtypes.Iterator< lambda.A > = it.iterator()
				while(x.hasNext()) {
					var x1: lambda.A = x.next()
					if(pred(x1)) ++n
				}
			}
			return n
		}

		static function empty(it: stdtypes.Iterable< lambda.T >): Bool {
			return !it.iterator().hasNext()
		}

		static function indexOf(it: stdtypes.Iterable< lambda.T >, v: lambda.T): Int {
			var i: Int = 0
			{
				var v2: stdtypes.Iterator< lambda.T > = it.iterator()
				while(v2.hasNext()) {
					var v21: lambda.T = v2.next()
					if(v == v21) return i
					i++
				}
			}
			return -1
		}

		static function find(it: stdtypes.Iterable< lambda.T >, f: lambda.T=>Bool): lambda.T? {
			{
				var v: stdtypes.Iterator< lambda.T > = it.iterator()
				while(v.hasNext()) {
					var v1: lambda.T = v.next()
					if(f(v1)) return v1
				}
			}
			return null
		}

		static function concat(a: stdtypes.Iterable< lambda.T >, b: stdtypes.Iterable< lambda.T >): List< lambda.T > {
			var l: List< lambda.T > = new List< lambda.T >()
			{
				var x: stdtypes.Iterator< lambda.T > = a.iterator()
				while(x.hasNext()) {
					var x1: lambda.T = x.next()
					l.add(x1)
				}
			}
			{
				var x2: stdtypes.Iterator< lambda.T > = b.iterator()
				while(x2.hasNext()) {
					var x3: lambda.T = x2.next()
					l.add(x3)
				}
			}
			return l
		}

	}
}
