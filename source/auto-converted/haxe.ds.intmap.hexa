module haxe.ds.intmap {
	@coreApi
	class IntMap< T > implements haxe.constraints.IMap< Int, T > {
		private var h: Any
		@has_untyped
		function set(key: Int, value: T): Void {
			this.h[key] = value
		}

		@has_untyped
		function get(key: Int): T? {
			return this.h[key]
		}

		@has_untyped
		function exists(key: Int): Bool {
			return this.h.hasOwnProperty(key)
		}

		@has_untyped
		function remove(key: Int): Bool {
			if (!this.h.hasOwnProperty(key)) return false
			__js__('delete')(this.h[key])
			return true
		}

		@has_untyped
		function keys(): stdtypes.Iterator< Int > {
			var a: [Int] = []
			__js__('for( var key in {0} ) {1}', this.h, if (this.h.hasOwnProperty(key)) a.push(key | 0))
			return HxOverrides.iter(a)
		}

		@has_untyped
		function iterator(): stdtypes.Iterator< T > {
			return {ref: this.h, it: this.keys(), hasNext: function(): Bool {
				return this.it.hasNext()
			}, next: function(): T {
				var i: Int = this.it.next()
				return this.ref[i]
			}}
		}

		function toString(): String {
			var s_b: String = ''
			s_b += '{'
			var it: stdtypes.Iterator< Int > = this.keys()
			{
				var i: stdtypes.Iterator< Int > = it
				while (i.hasNext()) {
					var i1: Int = i.next()
					s_b += if (i1 == null) 'null' else '' + i1
					s_b += ' => '
					s_b += Std.string(Std.string((this.h[i1] as! T?)))
					if (it.hasNext()) s_b += ', '
				}
			}
			s_b += '}'
			return s_b
		}

		new() {
			this.h = {:}
		}
	}
}
