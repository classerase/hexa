module {
	class GenC extends generator.GeneratorHelper {
		private static var nowrap: Bool = true
		private static var id: Int = 0
		private static var tabs: String = ''
		private static function rename(name: String): String {
			if (name != 'WinMain') return '$' + name
			return name
		}

		private static function unblock(e: data.Node): data.Node {
			if (e.index == 9) {
				if ({ let data.Node.TBlock(value) = e value }.length == 1) {
					var e1: data.Node = { let data.Node.TBlock(value) = e value }[0]
					return e1
				} else return e
			} else return e
		}

		private static function pushTab(): Void {
			GenC.tabs += '\t'
		}

		private static function popTab(): Void {
			GenC.tabs = GenC.tabs.substring(0, GenC.tabs.length - 1)
		}

		private static function stringifyBlockExpression(node: data.Node): String {
			var r: String = ''
			if (node.index == 11) {
				let data.Node.TIf(_, _, eelse) = node
				let data.Node.TIf(_, eif, _) = node
				let data.Node.TIf(econd, _, _) = node
				r += 'if(' + GenC.stringify(econd[0]) + ') '
				r += @ast(switch (eif) {
					case TBlock(_): {
						eif.stringify()
					}
					case _: {
						TBlock([eif]).stringify()
					}
				}) if (eif.index == 9) GenC.stringify(eif) else GenC.stringify(data.Node.TBlock({[eif]}))
				if (eelse != null) r += ' else ' + GenC.stringifyBlockExpression(eelse)
				return r
			} else return GenC.stringify(node)
		}

		private static function getAtt(atts: [data.Attribute], atname: String): data.Attribute {
			log.trace(atts, {fileName: 'GenC.hx', lineNumber: 64, className: 'GenC', methodName: 'getAtt'})
			if (atts != null && atts.length > 0) {
				var _g: Int = 0
				while (_g < atts.length) {
					var att: data.Attribute = atts[_g]
					_g++
					if (att.name == atname) return att
				}
			}
			return null
		}

		private static var parentNames: [data.Node:String] = new EnumValueMap< data.Node, String >()
		private static var scopes: [[String:Bool]] = {[new StringMap< Bool >()]}
		private static function pushScope(): Void {
			GenC.scopes.push(new StringMap< Bool >())
		}

		private static function popScope(): [String:Bool] {
			return GenC.scopes.pop()
		}

		private static function hasInScope(name: String): Bool {
			var _this: haxe.ds.stringmap.StringMap< Bool > = ((GenC.scopes[GenC.scopes.length - 1] as! map.IMap< String, Bool >) as! haxe.ds.stringmap.StringMap< Bool >)
			return (if (__js__('__map_reserved')[name] != null) _this.getReserved(name) else _this.h[(name as! Int)]) != null
		}

		private static function addToScope(name: String): Void {
			var _this: haxe.ds.stringmap.StringMap< Bool > = ((GenC.scopes[GenC.scopes.length - 1] as! map.IMap< String, Bool >) as! haxe.ds.stringmap.StringMap< Bool >)
			if (__js__('__map_reserved')[name] != null) _this.setReserved(name, true) else _this.h[(name as! Int)] = true
		}

		static function stringifyMain(node: data.Node, target: Any): String {
			GenC.nowrap = true
			var r: String = ''
			if (target.include.length > 0) r += '#include ' + Std.string(target.include.join('\r\n#include ')) + '\r\n\r\n'
			r += '// Hexa declarations\r\n'
			r += '#define Int int\r\n'
			r += '\r\n'
			r += GenC.stringify(node)
			return r
		}

		static function stringify(node: data.Node): String {
			var r: String = ''
			if (node == null) throw new HaxeError('Unable to print: node is null')
			var atts: [data.Attribute] = data.Project.mapAttributes.get(node)
			var a: String = ''
			if (atts != null && atts.length > 0) {
				var _g: Int = 0
				while (_g < atts.length) {
					var att: data.Attribute = atts[_g]
					_g++
					a += '/* @' + att.name + '*/ '
				}
			}
			var tmp: String
			switch (@exhaustive node.index) {
				case 0: {
					let data.Node.TString(s) = node
					tmp = 'L"' + s.split('\n').join('\\n').split('\r').join('\\r').split('"').join('\\"') + '"'
				}

				case 1: {
					let data.Node.TIdent(s1) = node
					log.trace('`' + s1 + '`', {fileName: 'GenC.hx', lineNumber: 123, className: 'GenC', methodName: 'stringify'})
					var source: data.Node = data.Project.mapNames.get(node)
					var n: String
					if (source == null) throw new HaxeError('Unmapped ' + Std.string(node)) else switch (source.index) {
						case 1: {
							let data.Node.TIdent(name) = source
							n = ((GenC.parentNames as! map.IMap< data.Node, String >) as! map.IMap< data.Node, String >).get(source)
						}

						case 19: {
							let data.Node.TFunction(name1, _, _, _) = source
							n = GenC.rename(name1)
						}

						case 20: {
							let data.Node.TVar(name2, _, _, _) = source
							var n1: String? = ((GenC.parentNames as! map.IMap< data.Node, String >) as! map.IMap< data.Node, String >).get(source)
							if (n1 == null) throw new HaxeError('TVar ' + name2 + ' parentNames null == ' + ((GenC.parentNames as! map.IMap< data.Node, String >) as! map.IMap< data.Node, String >).get(source))
							n = n1
						}

						case 22: {
							let data.Node.TClass(t, _, _, _, _) = source
							var rename: data.Attribute = GenC.getAtt(data.Project.mapAttributes.get(source), 'native')
							var name3: String = GenC.rename(GenC.extractTypeName(t))
							if (rename != null) log.trace('Got @native!', {fileName: 'GenC.hx', lineNumber: 146, className: 'GenC', methodName: 'stringify'})
							if (rename != null) {
								var _g1: data.Node = rename.values[0]
								if (_g1 == null) n = name3 else if (_g1.index == 0) {
									let data.Node.TString(s2) = _g1
									n = s2
								} else n = name3
							} else n = name3
						}

						case 32: if ({ let data.Node.TEnum(value, _) = source value }.index == 0) {
							let data.NodeType.Type(name4) = { let data.Node.TEnum(value, _) = source value }
							n = name4
						} else throw new HaxeError('' + s1 + ' ' + Std.string(source))

						case 40: if ({ let data.Node.TStatic(value) = source value }.index == 20) {
							let data.Node.TVar(name5, _, _, _) = { let data.Node.TStatic(value) = source value }
							let data.Node.TStatic(f) = source
							var static_source: data.Node = data.Project.mapNames.get(source)
							switch (static_source.index) {
								case 22: {
									let data.Node.TClass(t1, _, _, _, _) = static_source
									n = GenC.rename(GenC.extractTypeName(t1)) + '.' + GenC.rename(name5)
								}

								case 32: {
									let data.Node.TEnum(t2, _) = static_source
									n = GenC.rename(GenC.extractTypeName(t2)) + '.' + GenC.rename(name5)
								}
								
								case _: throw new HaxeError('static_source is ' + Std.string(static_source))
							}
						} else throw new HaxeError('' + s1 + ' ' + Std.string(source))

						case 41: {
							let data.Node.TFor(name6, _, _) = source
							n = ((GenC.parentNames as! map.IMap< data.Node, String >) as! map.IMap< data.Node, String >).get(source)
						}
						
						case _: throw new HaxeError('' + s1 + ' ' + Std.string(source))
					}
					if (data.Project.isExternal.get(source) == true) n = ((GenC.parentNames as! map.IMap< data.Node, String >) as! map.IMap< data.Node, String >).get(source)
					if (s1 == 'BeginPaint') log.trace('BeginPaint --> ' + n + ', parent -> ' + Std.string(source), {fileName: 'GenC.hx', lineNumber: 156, className: 'GenC', methodName: 'stringify'})
					tmp = n
				}

				case 2: switch (@exhaustive { let data.Node.TBool(value) = node value }) {
					case false: tmp = '0'

					case true: tmp = '1'
				}

				case 3: tmp = 'this'

				case 4: tmp = 'super'

				case 5: {
					let data.Node.TInt(s3) = node
					tmp = s3
				}

				case 6: {
					let data.Node.TFloat(s4) = node
					tmp = s4
				}

				case 7: tmp = 'NULL'

				case 8: {
					let data.Node.TBinop(_, _, b) = node
					let data.Node.TBinop(_, a1, _) = node
					let data.Node.TBinop(op, _, _) = node
					tmp = GenC.stringify(a1) + token.Token_Impl_.stringify(op) + GenC.stringify(b)
				}

				case 9: {
					let data.Node.TBlock(el) = node
					var wrap: Bool = !GenC.nowrap
					GenC.nowrap = false
					if (wrap) r = '{\n'
					GenC.pushScope()
					if (wrap) GenC.tabs += '\t'
					{
						var _g2: Int = 0
						while (_g2 < el.length) {
							var e: data.Node = el[_g2]
							_g2++
							r += GenC.tabs + GenC.stringifyBlockExpression(e) + ';\n'
						}
					}
					if (wrap) GenC.tabs = GenC.tabs.substring(0, GenC.tabs.length - 1)
					GenC.popScope()
					r += GenC.tabs
					if (wrap) r += '}'
					tmp = r
				}

				case 10: if ({ let data.Node.TCall(value, _, _) = node value }.index == 1) switch ({ let data.Node.TIdent(value) = { let data.Node.TCall(value, _, _) = node value } value }) {
					case '__instanceof__': if ({ let data.Node.TCall(_, value, _) = node value }.length == 2) {
						let data.Node.TCall(_, _, argNames) = node
						var kind: data.Node = { let data.Node.TCall(_, value, _) = node value }[1]
						var of: data.Node = { let data.Node.TCall(_, value, _) = node value }[0]
						tmp = GenC.stringify(of) + ' instanceof ' + GenC.stringify(kind)
					} else {
						let data.Node.TCall(_, _, argNames1) = node
						let data.Node.TCall(e1, _, _) = node
						let data.Node.TCall(_, el1, _) = node
						var tmp1: String = GenC.stringify(e1) + '('
						var _g3: [String] = []
						{
							var _g11: Int = 0
							while (_g11 < el1.length) {
								var e2: data.Node = el1[_g11]
								_g11++
								_g3.push(GenC.stringify(e2))
							}
						}
						tmp = tmp1 + _g3.join(',') + ')'
					}

					case '__typeof__': if ({ let data.Node.TCall(_, value, _) = node value }.length == 1) {
						let data.Node.TCall(_, _, argNames2) = node
						var of1: data.Node = { let data.Node.TCall(_, value, _) = node value }[0]
						tmp = 'typeof ' + GenC.stringify(of1)
					} else {
						let data.Node.TCall(_, _, argNames3) = node
						let data.Node.TCall(e3, _, _) = node
						let data.Node.TCall(_, el2, _) = node
						var tmp2: String = GenC.stringify(e3) + '('
						var _g4: [String] = []
						{
							var _g12: Int = 0
							while (_g12 < el2.length) {
								var e4: data.Node = el2[_g12]
								_g12++
								_g4.push(GenC.stringify(e4))
							}
						}
						tmp = tmp2 + _g4.join(',') + ')'
					}

					case 'refof': if ({ let data.Node.TCall(_, value, _) = node value }.length == 1) {
						let data.Node.TCall(_, _, argNames4) = node
						var of2: data.Node = { let data.Node.TCall(_, value, _) = node value }[0]
						tmp = '(&' + GenC.stringify(of2) + ')'
					} else {
						let data.Node.TCall(_, _, argNames5) = node
						let data.Node.TCall(e5, _, _) = node
						let data.Node.TCall(_, el3, _) = node
						var tmp3: String = GenC.stringify(e5) + '('
						var _g5: [String] = []
						{
							var _g13: Int = 0
							while (_g13 < el3.length) {
								var e6: data.Node = el3[_g13]
								_g13++
								_g5.push(GenC.stringify(e6))
							}
						}
						tmp = tmp3 + _g5.join(',') + ')'
					}
					
					case _: {
						let data.Node.TCall(_, _, argNames6) = node
						let data.Node.TCall(_, el4, _) = node
						let data.Node.TCall(e7, _, _) = node
						var tmp4: String = GenC.stringify(e7) + '('
						var _g6: [String] = []
						{
							var _g14: Int = 0
							while (_g14 < el4.length) {
								var e8: data.Node = el4[_g14]
								_g14++
								_g6.push(GenC.stringify(e8))
							}
						}
						tmp = tmp4 + _g6.join(',') + ')'
					}
				} else {
					let data.Node.TCall(_, _, argNames7) = node
					let data.Node.TCall(_, el5, _) = node
					let data.Node.TCall(e9, _, _) = node
					var tmp5: String = GenC.stringify(e9) + '('
					var _g7: [String] = []
					{
						var _g15: Int = 0
						while (_g15 < el5.length) {
							var e10: data.Node = el5[_g15]
							_g15++
							_g7.push(GenC.stringify(e10))
						}
					}
					tmp = tmp5 + _g7.join(',') + ')'
				}

				case 11: {
					let data.Node.TIf(_, _, eelse) = node
					let data.Node.TIf(_, eif, _) = node
					let data.Node.TIf(econd, _, _) = node
					var _g8: [String] = []
					{
						var _g16: Int = 0
						while (_g16 < econd.length) {
							var e11: data.Node = econd[_g16]
							_g16++
							_g8.push(GenC.stringify(e11))
						}
					}
					r = 'if(' + _g8.join(' && ') + ') ' + GenC.stringify(eif)
					if (eelse != null) r += ' else ' + GenC.stringify(eelse)
					tmp = r
				}

				case 12: {
					let data.Node.TParenthesis(e12) = node
					tmp = '(' + GenC.stringify(e12) + ')'
				}

				case 13: if ({ let data.Node.TReturn(value) = node value } == null) tmp = 'return' else if ({ let data.Node.TReturn(value) = node value }[1] == 9) {
					if ({ let data.Node?.TBlock(value) = { let data.Node.TReturn(value) = node value } value }.length == 0) tmp = 'return' else {
						let data.Node.TReturn(e13) = node
						tmp = 'return ' + GenC.stringify(e13)
					}
				} else {
					let data.Node.TReturn(e14) = node
					tmp = 'return ' + GenC.stringify(e14)
				}

				case 14: {
					let data.Node.TThrow(e15) = node
					tmp = 'throw ' + GenC.stringify(e15) + ''
				}

				case 15: tmp = 'break'

				case 16: tmp = 'continue'

				case 17: {
					let data.Node.TUnop(_, _, e16) = node
					let data.Node.TUnop(_, postfix, _) = node
					let data.Node.TUnop(op1, _, _) = node
					if (postfix) tmp = GenC.stringify(e16) + token.Token_Impl_.stringify(op1) else tmp = token.Token_Impl_.stringify(op1) + GenC.stringify(e16)
				}

				case 18: switch (@exhaustive { let data.Node.TWhile(_, _, value) = node value }) {
					case false: {
						let data.Node.TWhile(econd1, _, _) = node
						let data.Node.TWhile(_, e17, _) = node
						tmp = 'do{' + GenC.stringify(e17) + '}while(' + GenC.stringify(econd1) + ')'
					}

					case true: {
						let data.Node.TWhile(econd2, _, _) = node
						let data.Node.TWhile(_, e18, _) = node
						tmp = 'while(' + GenC.stringify(econd2) + ') ' + GenC.stringify(e18)
					}
				}

				case 19: {
					let data.Node.TFunction(_, _, _, rettype) = node
					let data.Node.TFunction(_, _, vars, _) = node
					let data.Node.TFunction(_, expr, _, _) = node
					let data.Node.TFunction(name7, _, _, _) = node
					r += GenC.extractTypeName(rettype)
					r += ' CALLBACK'
					if (name7 != null) r += ' ' + GenC.rename(name7)
					var _g17: [String] = []
					{
						var _g21: Int = 0
						while (_g21 < vars.length) {
							var v: data.Node = vars[_g21]
							_g21++
							var r1: String
							switch (v.index) {
								case 1: {
									let data.Node.TIdent(name8) = v
									var name9: String = GenC.rename(name8)
									((GenC.parentNames as! map.IMap< data.Node, String >) as! map.IMap< data.Node, String >).set(v, name9)
									r1 = name9
								}

								case 12: if ({ let data.Node.TParenthesis(value) = v value } == null) r1 = '' else throw new HaxeError(v)

								case 20: {
									let data.Node.TVar(_, t3, _, _) = v
									let data.Node.TVar(name10, _, _, _) = v
									var name11: String = GenC.rename(name10)
									((GenC.parentNames as! map.IMap< data.Node, String >) as! map.IMap< data.Node, String >).set(v, name11)
									r1 = GenC.extractTypeName(t3) + ' ' + name11 + ' lol'
								}
								
								case _: throw new HaxeError(v)
							}
							_g17.push(@ast(switch (v) {
								case TVar(name, t, _): {
									var name = name.rename()
									parentNames[v] = name
									t.extractTypeName() + ' ' + name + ' lol'
								}
								case TIdent(name): {
									var name = name.rename()
									parentNames[v] = name
								}
								case TParenthesis(null): {
									''
								}
								case _: {
									throw v
								}
							}) r1)
						}
					}
					r += '(' + _g17.join(', ') + ') '
					if (expr != null) {
						if (expr.index == 9) {
							let data.Node.TBlock(el6) = expr
							r += GenC.stringify(expr)
						} else {
							GenC.pushScope()
							GenC.tabs += '\t'
							r += '{\n' + GenC.tabs + GenC.stringify(expr) + ('\n\t' + GenC.tabs + '}')
							GenC.tabs = GenC.tabs.substring(0, GenC.tabs.length - 1)
							GenC.popScope()
						}
					} else r += '{}'
					tmp = r
				}

				case 20: {
					let data.Node.TVar(_, _, _, const) = node
					let data.Node.TVar(_, _, expr1, _) = node
					let data.Node.TVar(_, t4, _, _) = node
					let data.Node.TVar(oname, _, _, _) = node
					if (oname == null) throw new HaxeError('name is null for ' + Std.string(node))
					var es: String = ''
					if (expr1.index == 20) {
						let data.Node.TVar(_, _, exp1, _) = expr1
						let data.Node.TVar(_, t11, _, _) = expr1
						let data.Node.TVar(oname1, _, _, _) = expr1
						var a2: Int = 1
					}
					if (expr1 != null) es = ' = ' + GenC.stringify(expr1)
					GenC.addToScope(oname)
					var name12: String = GenC.rename(oname)
					if (GenC.hasInScope(oname)) name12 += '$' + ++GenC.id
					((GenC.parentNames as! map.IMap< data.Node, String >) as! map.IMap< data.Node, String >).set(node, name12)
					if (name12 == null) throw new HaxeError('name is null for ' + Std.string(node))
					if (((GenC.parentNames as! map.IMap< data.Node, String >) as! map.IMap< data.Node, String >).get(node) == null) throw new HaxeError('parentNames[node] is null for ' + Std.string(node))
					if (t4 != null) r = GenC.extractTypeName(t4)
					if (t4 == null) r = 'auto'
					r += ' ' + name12 + es
					tmp = r
				}

				case 21: {
					let data.Node.TVars(e19) = node
					var _g9: [String] = []
					{
						var _g18: Int = 0
						while (_g18 < e19.length) {
							var e20: data.Node = e19[_g18]
							_g18++
							_g9.push(GenC.stringify(e20))
						}
					}
					tmp = _g9.join('; ')
				}

				case 22: if ({ let data.Node.TClass(_, _, _, _, value) = node value } == true) {
					let data.Node.TClass(t5, _, _, _, _) = node
					let data.Node.TClass(_, ext, _, _, _) = node
					let data.Node.TClass(_, _, impl, _, _) = node
					let data.Node.TClass(_, _, _, fields, _) = node
					var cname: String = GenC.extractTypeName(t5)
					var require: data.Attribute = GenC.getAtt(data.Project.mapAttributes.get(node), 'require')
					if (require != null) {
						var _g10: data.Node = require.values[1]
						var _g19: data.Node = require.values[0]
						if (_g19.index == 0) {
							if (_g10 == null) {
								let data.Node.TString(s5) = _g19
								r += 'const ' + cname + ' = require("' + s5 + '");\n' + GenC.tabs
							} else if (_g10.index == 0) {
								let data.Node.TString(s6) = _g19
								let data.Node.TString(f1) = _g10
								r += 'const ' + cname + ' = require("' + s6 + '").' + f1 + ';\n' + GenC.tabs
							} else throw new HaxeError('@require takes string as argument')
						} else throw new HaxeError('@require takes string as argument')
					}
					r += '/* declare class ' + cname + ' */'
					tmp = r
				} else {
					let data.Node.TClass(t6, _, _, _, _) = node
					let data.Node.TClass(_, ext1, _, _, _) = node
					let data.Node.TClass(_, _, impl1, _, _) = node
					let data.Node.TClass(_, _, _, fields1, _) = node
					let data.Node.TClass(_, _, _, _, external) = node
					var cname1: String = GenC.extractTypeName(t6)
					r = (if (external) '/* declare class ' else 'class ') + cname1
					if (ext1 != null) r += ' extends ' + GenC.extractTypeName(ext1)
					r += ' {\n'
					var after: [String] = []
					{
						var _g20: Int = 0
						while (_g20 < fields1.length) {
							var f2: data.Node = fields1[_g20]
							_g20++
							var code: String = ''
							var statics: Bool = false
							function unmeta(f3: data.Node): data.Node {
								return f3
							}
							f2 = unmeta(f2)
							if (f2.index == 40) {
								let data.Node.TStatic(field) = f2
								{
									f2 = field
									statics = true
								}
							}
							f2 = unmeta(f2)
							switch (f2.index) {
								case 19: {
									let data.Node.TFunction(_, _, _, rettype1) = f2
									let data.Node.TFunction(_, _, vars1, _) = f2
									let data.Node.TFunction(_, expr2, _, _) = f2
									let data.Node.TFunction(name13, _, _, _) = f2
									{
										if (name13 == 'new') name13 = 'constructor'
										if (statics) code += cname1 + '.' + GenC.rename(name13) + ' = function' else code += '\t' + GenC.rename(name13)
										var _g22: [String] = []
										{
											var _g31: Int = 0
											while (_g31 < vars1.length) {
												var v1: data.Node = vars1[_g31]
												_g31++
												var code1: String
												if (v1.index == 20) {
													let data.Node.TVar(name14, _, _, _) = v1
													var name15: String = GenC.rename(name14)
													((GenC.parentNames as! map.IMap< data.Node, String >) as! map.IMap< data.Node, String >).set(v1, name15)
													code1 = name15
												} else throw new HaxeError(v1)
												_g22.push(@ast(switch (v) {
													case TVar(name, _, _): {
														var name = name.rename()
														parentNames[v] = name
													}
													case _: {
														throw v
													}
												}) code1)
											}
										}
										code += '(' + _g22.join(', ') + ') '
										if (expr2 != null) {
											if (expr2.index == 9) {
												let data.Node.TBlock(el7) = expr2
												{
													GenC.tabs += '\t'
													code += GenC.stringify(expr2)
													GenC.tabs = GenC.tabs.substring(0, GenC.tabs.length - 1)
												}
											} else {
												GenC.tabs += '\t'
												code += '{\n' + GenC.tabs + GenC.stringify(expr2)
												GenC.tabs = GenC.tabs.substring(0, GenC.tabs.length - 1)
												code += '\n' + GenC.tabs + '}'
											}
										} else code += '{}'
									}
								}

								case 20: {
									let data.Node.TVar(_, _, expr3, _) = f2
									let data.Node.TVar(_, t7, _, _) = f2
									let data.Node.TVar(name16, _, _, _) = f2
									code += cname1 + '.' + GenC.rename(name16) + ' = ' + GenC.stringify(expr3)
								}
								
								case _: code += '' + Std.string(f2)
							}
							if (statics) after.push(GenC.tabs + code) else r += '\t' + code
						}
					}
					r += '\n' + GenC.tabs + '}' + (if (external) ' */' else '')
					r += '\n' + after.join(';\n')
					tmp = r
				}

				case 23: {
					let data.Node.TTry(_, _, _, catches) = node
					let data.Node.TTry(_, _, v2, _) = node
					let data.Node.TTry(_, t8, _, _) = node
					let data.Node.TTry(expr4, _, _, _) = node
					r = 'try {\n' + GenC.tabs + '\t'
					GenC.tabs += '\t'
					if (expr4.index == 9) {
						let data.Node.TBlock(el8) = expr4
						var _g110: [String] = []
						{
							var _g23: Int = 0
							while (_g23 < el8.length) {
								var e21: data.Node = el8[_g23]
								_g23++
								_g110.push(GenC.stringifyBlockExpression(e21))
							}
						}
						r += _g110.join(';\n' + GenC.tabs)
					} else r += GenC.stringify(expr4)
					GenC.tabs = GenC.tabs.substring(0, GenC.tabs.length - 1)
					r += '\n' + GenC.tabs + '} catch(' + data.DataHelper.varName(v2[0]) + (') {\n' + GenC.tabs + '\t')
					GenC.tabs += '\t'
					{
						var this1: map.IMap< data.Node, String > = GenC.parentNames
						var value: String = data.DataHelper.varName(v2[0])
						(this1 as! map.IMap< data.Node, String >).set(v2[0], value)
					}
					{
						var _g24: data.Node = catches[0]
						if (_g24.index == 9) {
							let data.Node.TBlock(el9) = _g24
							var _g111: [String] = []
							{
								var _g25: Int = 0
								while (_g25 < el9.length) {
									var e22: data.Node = el9[_g25]
									_g25++
									_g111.push(GenC.stringify(e22))
								}
							}
							r += _g111.join(';\n' + GenC.tabs)
						} else r += GenC.stringify(catches[0])
					}
					GenC.tabs = GenC.tabs.substring(0, GenC.tabs.length - 1)
					tmp = r + '\n' + GenC.tabs + '}'
				}

				case 24: if ({ let data.Node.TDot(value, _) = node value }.index == 0) {
					if ({ let data.Node.TDot(_, value) = node value } == 'length') {
						let data.Node.TString(s7) = { let data.Node.TDot(value, _) = node value }
						tmp = '' + s7.length
					} else {
						let data.Node.TDot(expr5, _) = node
						let data.Node.TDot(_, name17) = node
						log.trace('.`' + name17 + '`', {fileName: 'GenC.hx', lineNumber: 227, className: 'GenC', methodName: 'stringify'})
						var parent: data.Node = data.Project.mapNames.get(expr5)
						if (parent.index == 32) {
							let data.Node.TEnum(_, fields2) = parent
							var v3: String = ''
							{
								var _g26: Int = 0
								while (_g26 < fields2.length) {
									var f4: data.Node = fields2[_g26]
									_g26++
									if (f4.index == 8) {
										if ({ let data.Node.TBinop(value, _, _) = f4 value } == 91) {
											if ({ let data.Node.TBinop(_, value, _) = f4 value }.index == 1) {
												if ({ let data.Node.TBinop(_, _, value) = f4 value }.index == 5) {
													let data.Node.TIdent(n2) = { let data.Node.TBinop(_, value, _) = f4 value }
													let data.Node.TInt(value1) = { let data.Node.TBinop(_, _, value) = f4 value }
													if (name17 == n2) v3 = '' + value1
												} else throw new HaxeError('' + Std.string(f4))
											} else throw new HaxeError('' + Std.string(f4))
										} else throw new HaxeError('' + Std.string(f4))
									} else throw new HaxeError('' + Std.string(f4))
								}
							}
							tmp = v3
						} else tmp = GenC.stringify(expr5) + '.' + name17
					}
				} else {
					let data.Node.TDot(_, name18) = node
					let data.Node.TDot(expr6, _) = node
					log.trace('.`' + name18 + '`', {fileName: 'GenC.hx', lineNumber: 227, className: 'GenC', methodName: 'stringify'})
					var parent1: data.Node = data.Project.mapNames.get(expr6)
					if (parent1.index == 32) {
						let data.Node.TEnum(_, fields3) = parent1
						var v4: String = ''
						{
							var _g27: Int = 0
							while (_g27 < fields3.length) {
								var f5: data.Node = fields3[_g27]
								_g27++
								if (f5.index == 8) {
									if ({ let data.Node.TBinop(value, _, _) = f5 value } == 91) {
										if ({ let data.Node.TBinop(_, value, _) = f5 value }.index == 1) {
											if ({ let data.Node.TBinop(_, _, value) = f5 value }.index == 5) {
												let data.Node.TIdent(n3) = { let data.Node.TBinop(_, value, _) = f5 value }
												let data.Node.TInt(value2) = { let data.Node.TBinop(_, _, value) = f5 value }
												if (name18 == n3) v4 = '' + value2
											} else throw new HaxeError('' + Std.string(f5))
										} else throw new HaxeError('' + Std.string(f5))
									} else throw new HaxeError('' + Std.string(f5))
								} else throw new HaxeError('' + Std.string(f5))
							}
						}
						tmp = v4
					} else tmp = GenC.stringify(expr6) + '.' + name18
				}

				case 25: {
					let data.Node.TNew(_, _, _, values) = node
					let data.Node.TNew(_, _, names, _) = node
					let data.Node.TNew(_, args, _, _) = node
					let data.Node.TNew(t9, _, _, _) = node
					var tmp6: String = 'new ' + GenC.extractTypeName(t9) + '('
					var _g28: [String] = []
					{
						var _g112: Int = 0
						while (_g112 < args.length) {
							var e23: data.Node = args[_g112]
							_g112++
							_g28.push(GenC.stringify(e23))
						}
					}
					tmp = tmp6 + _g28.join(',') + ')'
				}

				case 26: {
					let data.Node.TArray(el10) = node
					var _g29: [String] = []
					{
						var _g113: Int = 0
						while (_g113 < el10.length) {
							var e24: data.Node = el10[_g113]
							_g113++
							_g29.push(GenC.stringify(e24))
						}
					}
					tmp = '[' + _g29.join(',') + ']'
				}

				case 27: if ({ let data.Node.TMap(value, _) = node value }.length == 0) tmp = 'new Map()' else {
					let data.Node.TMap(_, values1) = node
					let data.Node.TMap(keys, _) = node
					var _g30: [String] = []
					{
						var _g210: Int = 0
						var _g114: Int = keys.length
						while (_g210 < _g114) {
							var i: Int = _g210++
							_g30.push('[' + GenC.stringify(keys[i]) + ',' + GenC.stringify(values1[i]) + ']')
						}
					}
					tmp = 'new Map([' + _g30.join(',') + '])'
				}

				case 28: {
					let data.Node.TIndex(_, index) = node
					let data.Node.TIndex(expr7, _) = node
					tmp = GenC.stringify(expr7) + '[' + GenC.stringify(index) + ']'
				}

				case 29: {
					let data.Node.TSwitch(_, _, cases) = node
					let data.Node.TSwitch(_, conds, _) = node
					let data.Node.TSwitch(exprs, _, _) = node
					r = 'switch ('
					r += GenC.stringify(exprs[0])
					r += ') {\n'
					GenC.tabs += '\t'
					{
						var _g115: Int = 0
						var _g32: Int = cases.length
						while (_g115 < _g32) {
							var i1: Int = _g115++
							var c: data.Node = cases[i1]
							r += GenC.tabs
							{
								var _g211: Int = 0
								var _g33: [data.Node] = conds[i1]
								while (_g211 < _g33.length) {
									var c1: data.Node = _g33[_g211]
									_g211++
									if (c1.index == 39) r += 'default:' else r += 'case ' + GenC.stringify(c1) + ':'
								}
							}
							r += ' {\n'
							r += GenC.tabs + '\t' + GenC.stringify(c) + ';\n'
							r += GenC.tabs + ('\tbreak;\n' + GenC.tabs + ';}\n')
						}
					}
					GenC.tabs = GenC.tabs.substring(0, GenC.tabs.length - 1)
					tmp = r + GenC.tabs + '}'
				}

				case 30: {
					let data.Node.TModule(_, el11) = node
					let data.Node.TModule(path, _) = node
					r = 'module ' + path.join('.') + ' {\n'
					GenC.tabs += '\t'
					{
						var _g34: Int = 0
						while (_g34 < el11.length) {
							var e25: data.Node = el11[_g34]
							_g34++
							r += GenC.tabs + GenC.stringify(e25) + ';\n'
						}
					}
					GenC.tabs = GenC.tabs.substring(0, GenC.tabs.length - 1)
					tmp = r + GenC.tabs + '}'
				}

				case 31: if ({ let data.Node.TObject(value, _) = node value }.length == 0) tmp = '{}' else {
					let data.Node.TObject(_, el12) = node
					let data.Node.TObject(names1, _) = node
					var _g35: [String] = []
					{
						var _g212: Int = 0
						var _g116: Int = el12.length
						while (_g212 < _g116) {
							var i2: Int = _g212++
							_g35.push(GenC.rename(names1[i2]) + ':' + GenC.stringify(el12[i2]))
						}
					}
					tmp = '{' + _g35.join(',') + '}'
				}

				case 32: {
					let data.Node.TEnum(_, fields4) = node
					let data.Node.TEnum(t10, _) = node
					r = '/*const ' + GenC.extractTypeName(t10)
					r += ' = {\n'
					GenC.tabs += '\t'
					{
						var _g36: Int = 0
						while (_g36 < fields4.length) {
							var f6: data.Node = fields4[_g36]
							_g36++
							switch (f6.index) {
								case 1: {
									let data.Node.TIdent(name19) = f6
									r += GenC.tabs + name19 + ':{},\n'
								}

								case 8: if ({ let data.Node.TBinop(value, _, _) = f6 value } == 91) {
									if ({ let data.Node.TBinop(_, value, _) = f6 value }.index == 1) {
										let data.Node.TBinop(_, _, val) = f6
										let data.Node.TIdent(name20) = { let data.Node.TBinop(_, value, _) = f6 value }
										r += GenC.tabs + name20 + ':' + GenC.stringify(val) + ',\n'
									} else throw new HaxeError('!' + Std.string(f6))
								} else throw new HaxeError('!' + Std.string(f6))
								
								case _: throw new HaxeError('!' + Std.string(f6))
							}
						}
					}
					GenC.tabs = GenC.tabs.substring(0, GenC.tabs.length - 1)
					tmp = r + GenC.tabs + '}*/'
				}

				case 33: {
					let data.Node.TEnumExtract(_, _, name21) = node
					let data.Node.TEnumExtract(_, extract, _) = node
					let data.Node.TEnumExtract(tenum, _, _) = node
					tmp = '/*tenumxtract*/'
				}

				case 34: {
					let data.Node.TType(_, t12) = node
					let data.Node.TType(name22, _) = node
					tmp = ''
				}

				case 35: {
					let data.Node.TDeclare(_, node1) = node
					let data.Node.TDeclare(name23, _) = node
					((GenC.parentNames as! map.IMap< data.Node, String >) as! map.IMap< data.Node, String >).set(node1, name23)
					data.Project.isExternal.set(node1, true)
					tmp = '//declare ' + name23
				}

				case 36: {
					let data.Node.TUsing(names2) = node
					tmp = '/*using ' + Std.string(names2) + '*/'
				}

				case 37: {
					let data.Node.TIs(_, t13) = node
					let data.Node.TIs(expr8, _) = node
					tmp = ''
				}

				case 38: {
					let data.Node.TAs(_, _, t14) = node
					let data.Node.TAs(_, kind, _) = node
					let data.Node.TAs(expr9, _, _) = node
					tmp = '((' + GenC.extractTypeName(t14) + ')(' + GenC.stringify(expr9) + '))'
				}

				case 39: tmp = '_'

				case 40: {
					let data.Node.TStatic(field1) = node
					tmp = 'static ' + GenC.stringify(field1)
				}

				case 41: {
					let data.Node.TFor(_, _, b1) = node
					let data.Node.TFor(_, a3, _) = node
					let data.Node.TFor(n4, _, _) = node
					var name24: String = GenC.rename(n4)
					if (GenC.hasInScope(name24)) name24 += '$' + ++GenC.id
					GenC.addToScope(name24)
					((GenC.parentNames as! map.IMap< data.Node, String >) as! map.IMap< data.Node, String >).set(node, name24)
					tmp = 'for(const ' + GenC.rename(name24) + ' of ' + GenC.stringify(a3) + ') ' + GenC.stringify(b1)
				}

				case 42: {
					let data.Node.TElvis(_, b2) = node
					let data.Node.TElvis(a4, _) = node
					tmp = GenC.stringify(a4) + '||' + GenC.stringify(b2)
				}

				case 43: {
					let data.Node.NodeTypeValue(type1) = node
					tmp = GenC.extractTypeName(type1)
				}
			}
			return a + @ast(switch (node) {
				case TEnumExtract(tenum, extract, name): {
					'/*tenumxtract*/'
				}
				case TUsing(names): {
					'/*using $names*/'
				}
				case TVars(e): {
					[for (e in e) stringify(e)].join('; ')
				}
				case TString(s): {
					'L"' + s.split('\n').join('\\n').split('\r').join('\\r').split('"').join('\\"') + '"'
				}
				case TIdent(s): {
					trace('`$s`')
					var source = Project.mapNames.get(node)
					var n = switch (source) {
						case null: {
							throw 'Unmapped $node'
						}
						case TEnum(Type(name), _): {
							name
						}
						case TFor(name, _, _): {
							parentNames[source]
						}
						case TIdent(name): {
							parentNames[source]
						}
						case TVar(name, _, _): {
							var n = parentNames[source]
							if (n == null) throw 'TVar $name parentNames null == ' + parentNames.get(source)
							n
						}
						case TStatic(f = TVar(name, _, _)): {
							var static_source = Project.mapNames.get(source)
							switch (static_source) {
								case TClass(t, _), TEnum(t, _): {
									t.extractTypeName().rename() + '.' + name.rename()
								}
								case _: {
									throw 'static_source is $static_source'
								}
							}
						}
						case TFunction(name, _): {
							name.rename()
						}
						case TClass(t, _): {
							var rename = getAtt(Project.mapAttributes.get(source), 'native')
							var name = t.extractTypeName().rename()
							if (rename != null) trace('Got @native!')
							if (rename != null) switch (rename.values[0]) {
								case null: {
									name
								}
								case TString(s): {
									s
								}
								case _: {
									name
								}
							} else name
						}
						case _: {
							throw '$s ' + source
						}
					}
					if (Project.isExternal.get(source) == true) n = parentNames[source]
					if (s == 'BeginPaint') trace('BeginPaint --> $n, parent -> $source')
					n
				}
				case TBool(true): {
					'1'
				}
				case TBool(false): {
					'0'
				}
				case TThis: {
					'this'
				}
				case TSuper: {
					'super'
				}
				case TInt(s): {
					s
				}
				case TFloat(s): {
					s
				}
				case TNull: {
					'NULL'
				}
				case TBreak: {
					'break'
				}
				case TContinue: {
					'continue'
				}
				case TBinop(op, a, b): {
					a.stringify() + op.stringify() + b.stringify()
				}
				case TBlock(el): {
					var wrap = !nowrap
					nowrap = false
					if (wrap) r = '{\n'
					pushScope()
					if (wrap) pushTab()
					for (e in el) switch (e) {
						case _: {
							r += tabs + e.stringifyBlockExpression() + ';\n'
						}
					}
					if (wrap) popTab()
					popScope()
					r += tabs
					if (wrap) r += '}'
					r
				}
				case TElvis(a, b): {
					a.stringify() + '||' + b.stringify()
				}
				case TFor(n, a, b): {
					var name = n.rename()
					if (hasInScope(name)) name += '$$' + (++id)
					addToScope(name)
					parentNames[node] = name
					'for(const ' + name.rename() + ' of ' + a.stringify() + ') ' + b.stringify()
				}
				case TCall(TIdent('__instanceof__'), [of, kind], argNames): {
					of.stringify() + ' instanceof ' + kind.stringify()
				}
				case TCall(TIdent('__typeof__'), [of], argNames): {
					'typeof ' + of.stringify()
				}
				case TCall(TIdent('refof'), [of], argNames): {
					'(&' + of.stringify() + ')'
				}
				case TCall(e, el, argNames): {
					e.stringify() + '(' + [for (e in el) e.stringify()].join(',') + ')'
				}
				case TParenthesis(e): {
					'(' + e.stringify() + ')'
				}
				case TReturn(null), TReturn(TBlock([])): {
					'return'
				}
				case TReturn(e): {
					'return ' + e.stringify()
				}
				case TThrow(e): {
					'throw ' + e.stringify() + ''
				}
				case TArray(el): {
					'[' + [for (e in el) e.stringify()].join(',') + ']'
				}
				case TMap([], _): {
					'new Map()'
				}
				case TMap(keys, values): {
					'new Map([' + [for (i in 0 ... keys.length) '[' + keys[i].stringify() + ',' + values[i].stringify() + ']'].join(',') + '])'
				}
				case TIf(econd, eif, eelse): {
					r = 'if(' + [for (e in econd) e.stringify()].join(' && ') + ') ' + eif.stringify()
					if (eelse != null) r += ' else ' + eelse.stringify()
					r
				}
				case TUnop(op, postfix, e): {
					if (postfix) e.stringify() + op.stringify() else op.stringify() + e.stringify()
				}
				case TWhile(econd, e, true): {
					'while(' + econd.stringify() + ') ' + e.stringify()
				}
				case TWhile(econd, e, false): {
					'do{' + e.stringify() + '}while(' + econd.stringify() + ')'
				}
				case NodeTypeValue(kind): {
					extractTypeName(kind)
				}
				case TDot(TString(s), 'length'): {
					'' + s.length
				}
				case TDot(expr, name): {
					trace('.`$name`')
					var parent = Project.mapNames.get(expr)
					switch (parent) {
						case TEnum(_, fields): {
							var v = ''
							for (f in fields) switch (f) {
								case TBinop(OpAssign, TIdent(n), TInt(value)): {
									if (name == n) v = '' + value
								}
								case _: {
									throw '' + f
								}
							}
							v
						}
						case _: {
							expr.stringify() + '.' + name
						}
					}
				}
				case TIndex(expr, index): {
					expr.stringify() + '[' + index.stringify() + ']'
				}
				case TIs(expr, t): {
					''
				}
				case TAs(expr, kind, t): {
					'((' + t.extractTypeName() + ')(' + expr.stringify() + '))'
				}
				case TFunction(name, expr, vars, rettype): {
					r += rettype.extractTypeName()
					r += ' CALLBACK'
					if (name != null) r += ' ' + name.rename()
					r += '(' + [for (v in vars) switch (v) {
						case TVar(name, t, _): {
							var name = name.rename()
							parentNames[v] = name
							t.extractTypeName() + ' ' + name + ' lol'
						}
						case TIdent(name): {
							var name = name.rename()
							parentNames[v] = name
						}
						case TParenthesis(null): {
							''
						}
						case _: {
							throw v
						}
					}].join(', ') + ') '
					if (expr != null) {
						switch (expr) {
							case TBlock(el): {
								r += expr.stringify()
							}
							case _: {
								pushScope()
								pushTab()
								r += '{\n$tabs' + expr.stringify() + '\n\t$tabs}'
								popTab()
								popScope()
							}
						}
					} else r += '{}'
					r
				}
				case TVar(oname, t, expr, const): {
					if (oname == null) throw 'name is null for $node'
					var es = ''
					switch (expr) {
						case TVar(oname1, t1, exp1, _): {
							var a = 1
						}
						case _: 
					}
					if (expr != null) es = ' = ' + expr.stringify()
					addToScope(oname)
					var name = oname.rename()
					if (hasInScope(oname)) name += '$$' + (++id)
					parentNames[node] = name
					if (name == null) throw 'name is null for $node'
					if (parentNames[node] == null) throw 'parentNames[node] is null for $node'
					if (t != null) r = t.extractTypeName()
					if (t == null) r = 'auto'
					r += ' ' + name + es
					r
				}
				case TTry(expr, t, v, catches): {
					r = 'try {\n$tabs\t'
					pushTab()
					switch (expr) {
						case TBlock(el): {
							r += [for (e in el) e.stringifyBlockExpression()].join(';\n' + tabs)
						}
						case _: {
							r += expr.stringify()
						}
					}
					popTab()
					r += '\n' + tabs + '} catch(' + v[0].varName() + ') {\n$tabs\t'
					pushTab()
					parentNames.set(v[0], v[0].varName())
					switch (catches[0]) {
						case TBlock(el): {
							r += [for (e in el) e.stringify()].join(';\n' + tabs)
						}
						case _: {
							r += catches[0].stringify()
						}
					}
					popTab()
					r + '\n' + tabs + '}'
				}
				case TNew(t, args, names, values): {
					'new ' + extractTypeName(t) + '(' + [for (e in args) e.stringify()].join(',') + ')'
				}
				case TSwitch(exprs, conds, cases): {
					r = 'switch ('
					r += exprs[0].stringify()
					r += ') {\n'
					pushTab()
					for (i in 0 ... cases.length) {
						var c = cases[i]
						r += tabs
						for (c in conds[i]) switch (c) {
							case TUnderscore: {
								r += 'default:'
							}
							case _: {
								r += 'case ' + c.stringify() + ':'
							}
						}
						r += ' {\n'
						r += tabs + '\t' + c.stringify() + ';\n'
						r += tabs + '\tbreak;\n$tabs;}\n'
					}
					popTab()
					r + tabs + '}'
				}
				case TClass(t, ext, impl, fields, true): {
					var cname = extractTypeName(t)
					var require = getAtt(Project.mapAttributes.get(node), 'require')
					if (require != null) switch [require.values[0], require.values[1]] {
						case [TString(s), null]: {
							r += 'const $cname = require("$s");\n$tabs'
						}
						case [TString(s), TString(f)]: {
							r += 'const $cname = require("$s").$f;\n$tabs'
						}
						case _: {
							throw '@require takes string as argument'
						}
					}
					r += '/* declare class $cname */'
				}
				case TClass(t, ext, impl, fields, external): {
					var cname = extractTypeName(t)
					r = (if (external) '/* declare class ' else 'class ') + cname
					if (ext != null) r += ' extends ' + extractTypeName(ext)
					r += ' {\n'
					var after = []
					for (f in fields) {
						var code = ''
						var statics = false
						function unmeta(f) {
							switch (f) {
								case _: {
									return f
								}
							}
						}
						f = unmeta(f)
						switch (f) {
							case TStatic(field): {
								f = field
								statics = true
							}
							case _: {
								{}
							}
						}
						f = unmeta(f)
						switch (f) {
							case TFunction(name, expr, vars, rettype): {
								{
									if (name == 'new') name = 'constructor'
									if (statics) code += cname + '.' + name.rename() + ' = function' else code += '\t' + name.rename()
									code += '(' + [for (v in vars) switch (v) {
										case TVar(name, _, _): {
											var name = name.rename()
											parentNames[v] = name
										}
										case _: {
											throw v
										}
									}].join(', ') + ') '
									if (expr != null) {
										switch (expr) {
											case TBlock(el): {
												pushTab()
												code += expr.stringify()
												popTab()
											}
											case _: {
												pushTab()
												code += '{\n$tabs' + expr.stringify()
												popTab()
												code += '\n$tabs}'
											}
										}
									} else code += '{}'
								}
							}
							case TVar(name, t, expr, _): {
								code += cname + '.' + name.rename() + ' = ' + expr.stringify()
							}
							case _: {
								code += '' + f
							}
						}
						if (statics) after.push(tabs + code) else r += '\t' + code
					}
					r += '\n' + tabs + '}' + (if (external) ' */' else '')
					r += '\n' + after.join(';\n')
					r
				}
				case TModule(path, el): {
					r = 'module ' + path.join('.') + ' {\n'
					pushTab()
					for (e in el) {
						r += tabs + e.stringify() + ';\n'
					}
					popTab()
					r + tabs + '}'
				}
				case TObject([], _): {
					'{}'
				}
				case TObject(names, el): {
					'{' + [for (i in 0 ... el.length) names[i].rename() + ':' + el[i].stringify()].join(',') + '}'
				}
				case TStatic(field): {
					'static ' + field.stringify()
				}
				case TEnum(t, fields): {
					r = '/*const ' + extractTypeName(t)
					r += ' = {\n'
					pushTab()
					for (f in fields) {
						switch (f) {
							case TBinop(OpAssign, TIdent(name), val): {
								r += tabs + name + ':' + val.stringify() + ',\n'
							}
							case TIdent(name): {
								r += tabs + name + ':{},\n'
							}
							case _: {
								throw '!' + f
							}
						}
					}
					popTab()
					r + tabs + '}*/'
				}
				case TType(name, t): {
					''
				}
				case TUnderscore: {
					'_'
				}
				case TDeclare(name, node): {
					parentNames[node] = name
					Project.isExternal.set(node, true)
					'//declare $name'
				}
			}) tmp
		}

		private static function unwrapBlock(e: data.Node): data.Node {
			if (e.index == 9) {
				if ({ let data.Node.TBlock(value) = e value }.length == 1) {
					var e1: data.Node = { let data.Node.TBlock(value) = e value }[0]
					return e1
				} else {
					let data.Node.TBlock(el) = e
					throw new HaxeError('Unwrapped block has multiple expressions')
				}
			} else return e
		}

		static function extractTypeName(t: data.NodeType): String {
			switch (t.index) {
				case 0: {
					let data.NodeType.Type(name) = t
					return name
				}

				case 1: {
					let data.NodeType.ParamentricType(name1, _) = t
					return name1
				}
				
				case _: throw new HaxeError('Type has no name: ' + Std.string(t))
			}
		}

	}
}
