module haxe.ds.hashmap {
	@inline
	class HashMap< K, V > {
		var value: haxe.ds.hashmap.HashMapData< K, V >
		@impl
		static function _new(): haxe.ds.hashmap.HashMap< K, V > {
			var this1: haxe.ds.hashmap.HashMapData< K, V > = new HashMapData< K, V >()
			return (this1 as! haxe.ds.hashmap.HashMap< K, V >)
		}

		@impl
		static function set(this1: haxe.ds.hashmap.HashMapData< K, V >, k: K, v: V): Void {
			{
				var _this: haxe.ds.intmap.IntMap< K > = this1.keys
				var key: Int = k.hashCode()
				_this.h[key] = k
			}
			{
				var _this1: haxe.ds.intmap.IntMap< V > = this1.values
				var key1: Int = k.hashCode()
				_this1.h[key1] = v
			}
		}

		@impl
		static function get(this1: haxe.ds.hashmap.HashMapData< K, V >, k: K): V? {
			var _this: haxe.ds.intmap.IntMap< V > = this1.values
			var key: Int = k.hashCode()
			return _this.h[key]
		}

		@impl
		static function exists(this1: haxe.ds.hashmap.HashMapData< K, V >, k: K): Bool {
			var _this: haxe.ds.intmap.IntMap< V > = this1.values
			var key: Int = k.hashCode()
			return _this.h.hasOwnProperty(key)
		}

		@impl
		static function remove(this1: haxe.ds.hashmap.HashMapData< K, V >, k: K): Bool {
			this1.values.remove(k.hashCode())
			return this1.keys.remove(k.hashCode())
		}

		@impl
		static function keys(this1: haxe.ds.hashmap.HashMapData< K, V >): stdtypes.Iterator< K > {
			return this1.keys.iterator()
		}

		@impl
		static function iterator(this1: haxe.ds.hashmap.HashMapData< K, V >): stdtypes.Iterator< V > {
			return this1.values.iterator()
		}

	}
}
