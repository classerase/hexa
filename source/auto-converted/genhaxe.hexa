module {
	class GenHaxe {
		static var generateComments: Bool = false
		private static var id: Int = 0
		private static var tabs: String = ''
		private static var postfix: String = '___'
		private static var reserved: [String] = {['untyped', 'trace', 'abstract', 'public', 'extern']}
		private static var internalTypes: [String] = {[]}
		private static function rename(name: String): String {
			if (GenHaxe.reserved.indexOf(name) != -1) return name + '___'
			return name
		}

		private static function unblock(e: data.Node): data.Node {
			if (e.index == 9) {
				if ({ let data.Node.TBlock(value) = e value }.length == 1) {
					var e1: data.Node = { let data.Node.TBlock(value) = e value }[0]
					return e1
				} else return e
			} else return e
		}

		private static function pushTab(): Void {
			GenHaxe.tabs += '\t'
		}

		private static function popTab(): Void {
			GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
		}

		private static function stringifyBlockExpression(node: data.Node): String {
			var r: String = ''
			switch (node.index) {
				case 11: if ({ let data.Node.TIf(value, _, _) = node value }.length == 1) {
					if ({ let data.Node.TIf(value, _, _) = node value }[0].index == 20) {
						let data.Node.TIf(_, _, eelse) = node
						let data.Node.TIf(_, eif, _) = node
						let data.Node.TVar(_, _, _, const) = { let data.Node.TIf(value, _, _) = node value }[0]
						let data.Node.TVar(_, _, expr, _) = { let data.Node.TIf(value, _, _) = node value }[0]
						let data.Node.TVar(_, t, _, _) = { let data.Node.TIf(value, _, _) = node value }[0]
						let data.Node.TVar(oname, _, _, _) = { let data.Node.TIf(value, _, _) = node value }[0]
						var cond: data.Node = { let data.Node.TIf(value, _, _) = node value }[0]
						r += '\n' + GenHaxe.tabs + '{\n'
						GenHaxe.tabs += '\t'
						GenHaxe.pushScope()
						GenHaxe.parentNames.set(cond, oname)
						r += GenHaxe.tabs + 'var ' + oname + ' = ' + GenHaxe.stringify(expr) + ';\n' + GenHaxe.tabs
						r += 'if(' + oname + ' != null) '
						r += @ast(switch (eif) {
							case TBlock(_): {
								eif.stringify()
							}
							case _: {
								TBlock([eif]).stringify()
							}
						}) if (eif.index == 9) GenHaxe.stringify(eif) else GenHaxe.stringify(data.Node.TBlock({[eif]}))
						if (eelse != null) r += ' else ' + GenHaxe.stringifyBlockExpression(eelse) + ';'
						GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
						GenHaxe.popScope()
						return r + '\n' + GenHaxe.tabs + '}'
					} else {
						let data.Node.TIf(_, _, eelse1) = node
						let data.Node.TIf(_, eif1, _) = node
						var econd: data.Node = { let data.Node.TIf(value, _, _) = node value }[0]
						r += 'if(' + GenHaxe.stringify(econd) + ') '
						r += @ast(switch (eif) {
							case TBlock(_): {
								eif.stringify()
							}
							case _: {
								TBlock([eif]).stringify()
							}
						}) if (eif1.index == 9) GenHaxe.stringify(eif1) else GenHaxe.stringify(data.Node.TBlock({[eif1]}))
						if (eelse1 != null) r += ' else ' + GenHaxe.stringifyBlockExpression(eelse1) + ''
						return r
					}
				} else {
					let data.Node.TIf(_, _, eelse2) = node
					let data.Node.TIf(_, eif2, _) = node
					let data.Node.TIf(econd1, _, _) = node
					GenHaxe.tabs += '\t'
					r += '{\n' + GenHaxe.tabs
					if (eelse2 != null) {
						GenHaxe.addToScope('else' + '___')
						r += 'var else' + '___' + ' = function() ' + GenHaxe.stringify(eelse2) + '\n' + GenHaxe.tabs
					}
					var depth: Int = 0
					var econds: [data.Node] = econd1
					var i: Int = 0
					var condsstr: String = ''
					var constsstr: String = ''
					function addCond(cond1: String): String {
						if (condsstr == '') return cond1 else return ' && ' + cond1
					}
					while (econds[i] != null) {
						var cond2: data.Node = econds[i]
						condsstr = ''
						constsstr = ''
						while (true) {
							var innercond: data.Node = econds[i]
							if (innercond.index == 20) {
								let data.Node.TVar(_, _, _, const1) = innercond
								let data.Node.TVar(_, _, expr1, _) = innercond
								let data.Node.TVar(_, t1, _, _) = innercond
								let data.Node.TVar(oname1, _, _, _) = innercond
								{
									log.trace('const for ' + oname1, {fileName: 'GenHaxe.hx', lineNumber: 116, className: 'GenHaxe', methodName: 'stringifyBlockExpression'})
									var name: String = GenHaxe.rename(oname1)
									GenHaxe.addToScope(name)
									GenHaxe.parentNames.set(cond2, name)
									constsstr += 'var ' + name + ' = ' + GenHaxe.stringify(expr1) + ';\n' + GenHaxe.tabs
									condsstr += addCond(name + ' != null')
								}
							} else condsstr += addCond(GenHaxe.stringify(innercond))
							if (econds[i + 1] != null) {
								var _g: data.Node = econds[i + 1]
								if (_g.index == 20) {
									let data.Node.TVar(_, _, _, const2) = _g
									let data.Node.TVar(_, _, expr2, _) = _g
									let data.Node.TVar(_, t2, _, _) = _g
									let data.Node.TVar(oname2, _, _, _) = _g
									break
								}
							}
							i++
							if (!(econds[i] != null)) break
						}
						r += constsstr
						r += 'if(' + condsstr + ') {'
						GenHaxe.tabs += '\t'
						r += '\n' + GenHaxe.tabs
						depth++
						i++
					}
					r += @ast(switch (eif) {
						case TBlock(_): {
							eif.stringify()
						}
						case _: {
							TBlock([eif]).stringify()
						}
					}) if (eif2.index == 9) GenHaxe.stringify(eif2) else GenHaxe.stringify(data.Node.TBlock({[eif2]}))
					while (depth > 0) {
						GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
						r += '\n' + GenHaxe.tabs + '}'
						if (eelse2 != null) r += ' else else' + '___' + '();'
						depth--
					}
					GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
					r += '\n' + GenHaxe.tabs + '}'
					return r
				}

				case 19: {
					let data.Node.TFunction(_, _, vars, _) = node
					let data.Node.TFunction(_, expr3, _, _) = node
					let data.Node.TFunction(name1, _, _, _) = node
					var newname: String = GenHaxe.rename(name1)
					var _g1: [String] = []
					{
						var _g11: Int = 0
						while (_g11 < vars.length) {
							var v: data.Node = vars[_g11]
							_g11++
							var vars1: String
							switch (v.index) {
								case 1: {
									let data.Node.TIdent(name2) = v
									GenHaxe.parentNames.set(v, GenHaxe.rename(name2))
									vars1 = GenHaxe.parentNames.get(v)
								}

								case 12: if ({ let data.Node.TParenthesis(value) = v value } == null) vars1 = '' else throw new HaxeError(v)

								case 20: {
									let data.Node.TVar(name3, _, _, _) = v
									GenHaxe.parentNames.set(v, GenHaxe.rename(name3))
									vars1 = GenHaxe.parentNames.get(v)
								}
								
								case _: throw new HaxeError(v)
							}
							_g1.push(@ast(switch (v) {
								case TVar(name, _, _), TIdent(name): {
									parentNames.set(v, name.rename())
									parentNames.get(v)
								}
								case TParenthesis(null): {
									''
								}
								case _: {
									throw v
								}
							}) vars1)
						}
					}
					var vars2: String = _g1.join(', ')
					var funcbody: String = ''
					if (expr3 != null) {
						if (expr3.index == 9) {
							let data.Node.TBlock(el) = expr3
							funcbody = GenHaxe.stringify(expr3)
						} else {
							GenHaxe.pushScope()
							GenHaxe.tabs += '\t'
							funcbody = '{\n' + GenHaxe.tabs + 'return ' + GenHaxe.stringify(expr3) + ('\n\t' + GenHaxe.tabs + '}')
							GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
							GenHaxe.popScope()
						}
					} else funcbody = '{}'
					return 'var ' + newname + ' = function(' + vars2 + ') ' + funcbody
				}
				
				case _: {
					log.trace(node, {fileName: 'GenHaxe.hx', lineNumber: 177, className: 'GenHaxe', methodName: 'stringifyBlockExpression'})
					return GenHaxe.stringify(node)
				}
			}
		}

		private static function getAtt(atts: [data.Attribute], atname: String): data.Attribute {
			log.trace(atts, {fileName: 'GenHaxe.hx', lineNumber: 183, className: 'GenHaxe', methodName: 'getAtt'})
			if (atts != null && atts.length > 0) {
				var _g: Int = 0
				while (_g < atts.length) {
					var att: data.Attribute = atts[_g]
					_g++
					if (att.name == atname) return att
				}
			}
			return null
		}

		private static var parentNames: nodejs.JSMap< data.Node, String > = new JSMap< data.Node, String >()
		private static var scopes: [nodejs.JSMap< String, Bool >] = {[new JSMap< String, Bool >()]}
		private static function pushScope(): Void {
			GenHaxe.scopes.push(new JSMap< String, Bool >())
		}

		private static function popScope(): Void {
			GenHaxe.scopes.pop()
		}

		private static function hasInScope(name: String): Bool {
			return GenHaxe.scopes[GenHaxe.scopes.length - 1].get(name) != null
		}

		private static function addToScope(name: String): Void {
			GenHaxe.scopes[GenHaxe.scopes.length - 1].set(name, true)
		}

		@has_untyped
		static function stringify(node: data.Node): String {
			var r: String = ''
			if (node == null) throw new HaxeError('Unable to print: node is null')
			var atts: [data.Attribute] = data.Project.mapAttributes.get(node)
			var a: String = ''
			if (atts != null && atts.length > 0) {
				var _g: Int = 0
				while (_g < atts.length) {
					var att: data.Attribute = atts[_g]
					_g++
					if (att.name == 'untyped') a += 'untyped '
				}
			}
			var tmp: String
			switch (@exhaustive node.index) {
				case 0: {
					let data.Node.TString(s) = node
					var s1: [String] = s.split('')
					var charsOut: [String] = []
					while (s1.length > 0) {
						var _g1: String = s1[0]
						switch (_g1) {
							case '\n': {
								charsOut.push('\\n')
								s1.shift()
							}

							case '\r': {
								charsOut.push('\\r')
								s1.shift()
							}

							case '"': {
								charsOut.push('\\"')
								s1.shift()
							}

							case '\\': {
								s1.shift()
								if (s1[0] == '"') {
									charsOut.push('\\"')
									s1.shift()
								} else charsOut.push('\\')
							}
							
							case _: {
								charsOut.push(s1[0])
								s1.shift()
							}
						}
					}
					tmp = '"' + charsOut.join('') + '"'
				}

				case 1: {
					let data.Node.TIdent(s2) = node
					log.trace('`' + s2 + '`', {fileName: 'GenHaxe.hx', lineNumber: 263, className: 'GenHaxe', methodName: 'stringify'})
					var source: data.Node = data.Project.mapNames.get(node)
					var n: String
					if (source == null) throw new HaxeError('Unmapped ' + Std.string(node)) else switch (source.index) {
						case 1: {
							let data.Node.TIdent(name) = source
							n = GenHaxe.parentNames.get(source)
						}

						case 19: {
							let data.Node.TFunction(name1, _, _, _) = source
							n = GenHaxe.rename(name1)
						}

						case 20: {
							let data.Node.TVar(name2, _, _, _) = source
							var n1: String = GenHaxe.parentNames.get(source)
							if (n1 == null) throw new HaxeError('TVar `' + name2 + '` parentNames null == ' + GenHaxe.parentNames.get(source))
							n = n1
						}

						case 22: {
							let data.Node.TClass(t, _, _, _, _) = source
							var name3: String = GenHaxe.rename(GenHaxe.extractTypeName(t))
							var externAtt: data.Attribute = GenHaxe.getAtt(data.Project.mapAttributes.get(source), 'extern')
							var n2: Bool = externAtt != null
							var rename: data.Attribute = GenHaxe.getAtt(data.Project.mapAttributes.get(source), 'native')
							if (rename != null) log.trace('Got @native!', {fileName: 'GenHaxe.hx', lineNumber: 289, className: 'GenHaxe', methodName: 'stringify'})
							if (rename != null) {
								var _g2: data.Node = rename.values[0]
								if (_g2 == null) n = name3 else if (_g2.index == 0) {
									let data.Node.TString(s3) = _g2
									n = s3
								} else n = name3
							} else n = name3
						}

						case 32: if ({ let data.Node.TEnum(value, _) = source value }.index == 0) {
							let data.NodeType.Type(name4) = { let data.Node.TEnum(value, _) = source value }
							n = name4
						} else throw new HaxeError('' + s2 + ' ' + Std.string(source))

						case 40: if ({ let data.Node.TStatic(value) = source value }.index == 20) {
							let data.Node.TVar(name5, _, _, _) = { let data.Node.TStatic(value) = source value }
							let data.Node.TStatic(f) = source
							var static_source: data.Node = data.Project.mapNames.get(source)
							switch (static_source.index) {
								case 22: {
									let data.Node.TClass(t1, _, _, _, _) = static_source
									n = GenHaxe.rename(GenHaxe.extractTypeName(t1)) + '.' + GenHaxe.rename(name5)
								}

								case 32: {
									let data.Node.TEnum(t2, _) = static_source
									n = GenHaxe.rename(GenHaxe.extractTypeName(t2)) + '.' + GenHaxe.rename(name5)
								}
								
								case _: throw new HaxeError('static_source is ' + Std.string(static_source))
							}
						} else throw new HaxeError('' + s2 + ' ' + Std.string(source))

						case 41: {
							let data.Node.TFor(name6, _, _) = source
							log.trace('`' + s2 + '`', {fileName: 'GenHaxe.hx', lineNumber: 268, className: 'GenHaxe', methodName: 'stringify'})
							n = GenHaxe.parentNames.get(source)
						}
						
						case _: throw new HaxeError('' + s2 + ' ' + Std.string(source))
					}
					tmp = n
				}

				case 2: {
					let data.Node.TBool(b) = node
					tmp = '' + (if (b == null) 'null' else '' + b)
				}

				case 3: tmp = 'this'

				case 4: tmp = 'super'

				case 5: {
					let data.Node.TInt(s4) = node
					tmp = s4
				}

				case 6: {
					let data.Node.TFloat(s5) = node
					tmp = s5
				}

				case 7: tmp = 'null'

				case 8: {
					let data.Node.TBinop(_, _, b1) = node
					let data.Node.TBinop(_, a1, _) = node
					let data.Node.TBinop(op, _, _) = node
					tmp = GenHaxe.stringify(a1) + ' ' + token.Token_Impl_.stringify(op) + ' ' + GenHaxe.stringify(b1)
				}

				case 9: if ({ let data.Node.TBlock(value) = node value }.length == 0) tmp = '{}' else {
					let data.Node.TBlock(elements) = node
					r = '{\n'
					GenHaxe.pushScope()
					GenHaxe.tabs += '\t'
					{
						var _g3: Int = 0
						while (_g3 < elements.length) {
							var element: data.Node = elements[_g3]
							_g3++
							{
								var code: String = GenHaxe.tabs + GenHaxe.stringifyBlockExpression(element) + ';\n'
								if (element.index != 9 && code.length < 256) log.trace('Generated block expression `' + code.trim() + '`', {fileName: 'GenHaxe.hx', lineNumber: 321, className: 'GenHaxe', methodName: 'stringify'})
								r += code
							}
						}
					}
					GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
					GenHaxe.popScope()
					tmp = r + GenHaxe.tabs + '}'
				}

				case 10: if ({ let data.Node.TCall(value, _, _) = node value }.index == 1) switch ({ let data.Node.TIdent(value) = { let data.Node.TCall(value, _, _) = node value } value }) {
					case '__instanceof__': if ({ let data.Node.TCall(_, value, _) = node value }.length == 2) {
						let data.Node.TCall(_, _, argNames) = node
						var kind: data.Node = { let data.Node.TCall(_, value, _) = node value }[1]
						var of: data.Node = { let data.Node.TCall(_, value, _) = node value }[0]
						tmp = 'untyped __instanceof__(' + GenHaxe.stringify(of) + ', ' + GenHaxe.stringify(kind) + ')'
					} else {
						let data.Node.TCall(_, _, argNames1) = node
						let data.Node.TCall(e, _, _) = node
						let data.Node.TCall(_, el, _) = node
						var tmp1: String = GenHaxe.stringify(e) + '('
						var _g4: [String] = []
						{
							var _g11: Int = 0
							while (_g11 < el.length) {
								var e1: data.Node = el[_g11]
								_g11++
								_g4.push(GenHaxe.stringify(e1))
							}
						}
						tmp = tmp1 + _g4.join(', ') + ')'
					}

					case 'require': if ({ let data.Node.TCall(_, value, _) = node value }.length == 1) {
						let data.Node.TCall(_, _, argNames2) = node
						var container: data.Node = { let data.Node.TCall(_, value, _) = node value }[0]
						tmp = 'untyped require(' + GenHaxe.stringify(container) + ')'
					} else {
						let data.Node.TCall(_, _, argNames3) = node
						let data.Node.TCall(e2, _, _) = node
						let data.Node.TCall(_, el1, _) = node
						var tmp2: String = GenHaxe.stringify(e2) + '('
						var _g5: [String] = []
						{
							var _g12: Int = 0
							while (_g12 < el1.length) {
								var e3: data.Node = el1[_g12]
								_g12++
								_g5.push(GenHaxe.stringify(e3))
							}
						}
						tmp = tmp2 + _g5.join(', ') + ')'
					}
					
					case _: {
						let data.Node.TCall(_, _, argNames4) = node
						let data.Node.TCall(_, el2, _) = node
						let data.Node.TCall(e4, _, _) = node
						var tmp3: String = GenHaxe.stringify(e4) + '('
						var _g6: [String] = []
						{
							var _g13: Int = 0
							while (_g13 < el2.length) {
								var e5: data.Node = el2[_g13]
								_g13++
								_g6.push(GenHaxe.stringify(e5))
							}
						}
						tmp = tmp3 + _g6.join(', ') + ')'
					}
				} else {
					let data.Node.TCall(_, _, argNames5) = node
					let data.Node.TCall(_, el3, _) = node
					let data.Node.TCall(e6, _, _) = node
					var tmp4: String = GenHaxe.stringify(e6) + '('
					var _g7: [String] = []
					{
						var _g14: Int = 0
						while (_g14 < el3.length) {
							var e7: data.Node = el3[_g14]
							_g14++
							_g7.push(GenHaxe.stringify(e7))
						}
					}
					tmp = tmp4 + _g7.join(', ') + ')'
				}

				case 11: {
					let data.Node.TIf(_, _, eelse) = node
					let data.Node.TIf(_, eif, _) = node
					let data.Node.TIf(econd, _, _) = node
					var _g8: [String] = []
					{
						var _g15: Int = 0
						while (_g15 < econd.length) {
							var e8: data.Node = econd[_g15]
							_g15++
							_g8.push(GenHaxe.stringify(e8))
						}
					}
					r = '(' + _g8.join(' && ') + ')? (' + GenHaxe.stringify(eif)
					if (eelse != null) r += ') : (' + GenHaxe.stringify(eelse) + ')'
					tmp = r
				}

				case 12: {
					let data.Node.TParenthesis(e9) = node
					tmp = '(' + GenHaxe.stringify(e9) + ')'
				}

				case 13: if ({ let data.Node.TReturn(value) = node value } == null) tmp = 'return ' else if ({ let data.Node.TReturn(value) = node value }[1] == 9) {
					if ({ let data.Node?.TBlock(value) = { let data.Node.TReturn(value) = node value } value }.length == 0) tmp = 'return ' else {
						let data.Node.TReturn(e10) = node
						tmp = 'return ' + GenHaxe.stringify(e10)
					}
				} else {
					let data.Node.TReturn(e11) = node
					tmp = 'return ' + GenHaxe.stringify(e11)
				}

				case 14: {
					let data.Node.TThrow(e12) = node
					tmp = 'throw ' + GenHaxe.stringify(e12) + ''
				}

				case 15: tmp = 'break'

				case 16: tmp = 'continue'

				case 17: {
					let data.Node.TUnop(_, _, e13) = node
					let data.Node.TUnop(_, isPostfix, _) = node
					let data.Node.TUnop(op1, _, _) = node
					if (isPostfix) tmp = GenHaxe.stringify(e13) + token.Token_Impl_.stringify(op1) else tmp = token.Token_Impl_.stringify(op1) + GenHaxe.stringify(e13)
				}

				case 18: switch (@exhaustive { let data.Node.TWhile(_, _, value) = node value }) {
					case false: {
						let data.Node.TWhile(econd1, _, _) = node
						let data.Node.TWhile(_, e14, _) = node
						tmp = 'do{' + GenHaxe.stringify(e14) + '}while(' + GenHaxe.stringify(econd1) + ')'
					}

					case true: {
						let data.Node.TWhile(econd2, _, _) = node
						let data.Node.TWhile(_, e15, _) = node
						tmp = 'while(' + GenHaxe.stringify(econd2) + ') ' + GenHaxe.stringify(e15)
					}
				}

				case 19: {
					let data.Node.TFunction(_, _, vars, _) = node
					let data.Node.TFunction(_, expr, _, _) = node
					let data.Node.TFunction(name7, _, _, _) = node
					r = 'function'
					if (name7 != null) r += ' ' + GenHaxe.rename(name7)
					var _g16: [String] = []
					{
						var _g21: Int = 0
						while (_g21 < vars.length) {
							var v: data.Node = vars[_g21]
							_g21++
							var r1: String
							switch (v.index) {
								case 1: {
									let data.Node.TIdent(name8) = v
									GenHaxe.parentNames.set(v, GenHaxe.rename(name8))
									r1 = GenHaxe.parentNames.get(v)
								}

								case 12: if ({ let data.Node.TParenthesis(value) = v value } == null) r1 = '' else throw new HaxeError(v)

								case 20: {
									let data.Node.TVar(_, _, e16, _) = v
									let data.Node.TVar(_, t3, _, _) = v
									let data.Node.TVar(name9, _, _, _) = v
									GenHaxe.parentNames.set(v, GenHaxe.rename(name9))
									var code1: String = GenHaxe.parentNames.get(v)
									if (t3 != null && GenHaxe.extractTypeString(t3).length > 0) code1 += ': ' + GenHaxe.rename(GenHaxe.extractTypeString(t3))
									if (e16 != null) code1 += ' = ' + GenHaxe.stringify(e16)
									r1 = code1
								}
								
								case _: throw new HaxeError(v)
							}
							_g16.push(@ast(switch (v) {
								case TIdent(name): {
									parentNames.set(v, name.rename())
									parentNames.get(v)
								}
								case TVar(name, t, e, _): {
									parentNames.set(v, name.rename())
									var code = parentNames.get(v)
									if (t != null && t.extractTypeString().length > 0) code += ': ' + t.extractTypeString().rename()
									if (e != null) code += ' = ' + e.stringify()
									code
								}
								case TParenthesis(null): {
									''
								}
								case _: {
									throw v
								}
							}) r1)
						}
					}
					r += '(' + _g16.join(', ') + ') '
					if (expr != null) {
						if (expr.index == 9) {
							let data.Node.TBlock(el4) = expr
							r += GenHaxe.stringify(expr)
						} else {
							GenHaxe.pushScope()
							GenHaxe.tabs += '\t'
							r += '{\n' + GenHaxe.tabs
							if (name7 == null) r += 'return '
							r += GenHaxe.stringify(expr) + (';\n\t' + GenHaxe.tabs + '}')
							GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
							GenHaxe.popScope()
						}
					} else r += '{}'
					tmp = r
				}

				case 20: {
					let data.Node.TVar(_, _, _, const) = node
					let data.Node.TVar(_, _, expr1, _) = node
					let data.Node.TVar(_, t4, _, _) = node
					let data.Node.TVar(oname, _, _, _) = node
					if (oname == null) throw new HaxeError('name is null for ' + Std.string(node))
					var es: String = ''
					if (expr1 != null) es = ' = ' + GenHaxe.stringify(expr1)
					var name10: String = GenHaxe.rename(oname)
					if (GenHaxe.hasInScope(oname)) name10 += ++GenHaxe.id + '___'
					GenHaxe.addToScope(oname)
					GenHaxe.parentNames.set(node, name10)
					if (name10 == null) throw new HaxeError('name is null for ' + Std.string(node))
					r = (if (const) 'var ' else 'var ') + name10 + es
					tmp = r
				}

				case 21: {
					let data.Node.TVars(e17) = node
					var _g9: [String] = []
					{
						var _g17: Int = 0
						while (_g17 < e17.length) {
							var e18: data.Node = e17[_g17]
							_g17++
							_g9.push(GenHaxe.stringify(e18))
						}
					}
					tmp = _g9.join('; ')
				}

				case 22: if ({ let data.Node.TClass(_, _, _, _, value) = node value } == true) {
					let data.Node.TClass(t5, _, _, _, _) = node
					let data.Node.TClass(_, ext, _, _, _) = node
					let data.Node.TClass(_, _, impl, _, _) = node
					let data.Node.TClass(_, _, _, fields, _) = node
					var cname: String = GenHaxe.extractTypeName(t5)
					var require: data.Attribute = GenHaxe.getAtt(data.Project.mapAttributes.get(node), 'require')
					if (require != null) {
						var _g10: data.Node = require.values[1]
						var _g18: data.Node = require.values[0]
						if (_g18.index == 0) {
							if (_g10 == null) {
								let data.Node.TString(s6) = _g18
								r += '@:jsRequire("' + s6 + '")'
							} else if (_g10.index == 0) {
								let data.Node.TString(s7) = _g18
								let data.Node.TString(f1) = _g10
								r += '@:jsRequire("' + s7 + '", "' + f1 + '")'
							} else throw new HaxeError('@require takes string as argument')
						} else throw new HaxeError('@require takes string as argument')
					}
					r += '/* extern class ' + cname + ' */'
					tmp = r
				} else {
					let data.Node.TClass(t6, _, _, _, _) = node
					let data.Node.TClass(_, ext1, _, _, _) = node
					let data.Node.TClass(_, _, impl1, _, _) = node
					let data.Node.TClass(_, _, _, fields1, _) = node
					let data.Node.TClass(_, _, _, _, external) = node
					var cname1: String = GenHaxe.extractTypeName(t6)
					r = (if (external) '/* extern class ' else 'class ') + cname1
					if (ext1 != null) r += ' extends ' + GenHaxe.extractTypeName(ext1)
					r += ' {\n'
					{
						var _g19: Int = 0
						while (_g19 < fields1.length) {
							var f2: data.Node = fields1[_g19]
							_g19++
							var code2: String = ''
							var isStatic: Bool = false
							function unmeta(f3: data.Node): data.Node {
								return f3
							}
							f2 = unmeta(f2)
							if (f2.index == 40) {
								let data.Node.TStatic(field) = f2
								{
									f2 = field
									isStatic = true
								}
							}
							f2 = unmeta(f2)
							GenHaxe.tabs += '\t'
							switch (f2.index) {
								case 19: {
									let data.Node.TFunction(_, _, vars1, _) = f2
									let data.Node.TFunction(_, expr2, _, _) = f2
									let data.Node.TFunction(name11, _, _, _) = f2
									{
										if (name11 == 'new') code2 += 'public function new' else if (isStatic) code2 += 'public static function ' + GenHaxe.rename(name11) else code2 += 'public function ' + GenHaxe.rename(name11)
										var _g22: [String] = []
										{
											var _g31: Int = 0
											while (_g31 < vars1.length) {
												var v1: data.Node = vars1[_g31]
												_g31++
												var code3: String
												if (v1.index == 20) {
													let data.Node.TVar(name12, _, _, _) = v1
													var name13: String = GenHaxe.rename(name12)
													GenHaxe.parentNames.set(v1, name13)
													code3 = GenHaxe.parentNames.get(v1)
												} else throw new HaxeError(v1)
												_g22.push(@ast(switch (v) {
													case TVar(name, _, _): {
														var name = name.rename()
														parentNames.set(v, name)
														parentNames.get(v)
													}
													case _: {
														throw v
													}
												}) code3)
											}
										}
										code2 += '(' + _g22.join(', ') + ') '
										if (expr2 != null) {
											if (expr2.index == 9) {
												GenHaxe.tabs += '\t'
												code2 += GenHaxe.stringify(expr2)
												GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
											} else {
												GenHaxe.tabs += '\t'
												code2 += '{\n' + GenHaxe.tabs + GenHaxe.stringify(expr2)
												GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
												code2 += ';\n' + GenHaxe.tabs + '}'
											}
										} else code2 += '{}'
									}
								}

								case 20: {
									let data.Node.TVar(_, _, _, const1) = f2
									let data.Node.TVar(_, _, expr3, _) = f2
									let data.Node.TVar(_, t7, _, _) = f2
									let data.Node.TVar(name14, _, _, _) = f2
									{
										code2 += 'public static var ' + GenHaxe.rename(name14)
										if (expr3 != null) code2 += ' = ' + GenHaxe.stringify(expr3)
										code2 += ';'
									}
								}
								
								case _: code2 += '' + Std.string(f2)
							}
							code2 += '\n'
							GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
							r += '\t' + code2
						}
					}
					r += '' + GenHaxe.tabs + '}' + (if (external) ' */' else '')
					tmp = r
				}

				case 23: {
					let data.Node.TTry(_, _, _, catches) = node
					let data.Node.TTry(_, _, v2, _) = node
					let data.Node.TTry(_, t8, _, _) = node
					let data.Node.TTry(expr4, _, _, _) = node
					r = 'try {\n' + GenHaxe.tabs + '\t'
					GenHaxe.tabs += '\t'
					if (expr4.index == 9) {
						let data.Node.TBlock(el5) = expr4
						var _g110: [String] = []
						{
							var _g23: Int = 0
							while (_g23 < el5.length) {
								var e19: data.Node = el5[_g23]
								_g23++
								_g110.push(GenHaxe.stringifyBlockExpression(e19))
							}
						}
						r += _g110.join(';\n' + GenHaxe.tabs)
					} else r += GenHaxe.stringify(expr4)
					GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
					r += '\n' + GenHaxe.tabs + '} catch(' + data.DataHelper.varName(v2[0]) + (': Any) {\n' + GenHaxe.tabs + '\t')
					GenHaxe.tabs += '\t'
					GenHaxe.parentNames.set(v2[0], data.DataHelper.varName(v2[0]))
					{
						var _g20: data.Node = catches[0]
						if (_g20.index == 9) {
							if ({ let data.Node.TBlock(value) = _g20 value }.length != 0) {
								let data.Node.TBlock(el6) = _g20
								var _g111: [String] = []
								{
									var _g24: Int = 0
									while (_g24 < el6.length) {
										var e20: data.Node = el6[_g24]
										_g24++
										_g111.push(GenHaxe.stringifyBlockExpression(e20))
									}
								}
								r += _g111.join(';\n' + GenHaxe.tabs) + ';'
							}
						} else r += GenHaxe.stringify(catches[0])
					}
					GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
					tmp = r + '\n' + GenHaxe.tabs + '}'
				}

				case 24: if ({ let data.Node.TDot(value, _) = node value }.index == 0) {
					if ({ let data.Node.TDot(_, value) = node value } == 'length') {
						let data.Node.TString(s8) = { let data.Node.TDot(value, _) = node value }
						tmp = '' + s8.length
					} else {
						let data.Node.TDot(expr5, _) = node
						let data.Node.TDot(_, name15) = node
						log.trace('.`' + name15 + '`', {fileName: 'GenHaxe.hx', lineNumber: 391, className: 'GenHaxe', methodName: 'stringify'})
						tmp = GenHaxe.stringify(expr5) + '.' + GenHaxe.rename(name15)
					}
				} else {
					let data.Node.TDot(_, name16) = node
					let data.Node.TDot(expr6, _) = node
					log.trace('.`' + name16 + '`', {fileName: 'GenHaxe.hx', lineNumber: 391, className: 'GenHaxe', methodName: 'stringify'})
					tmp = GenHaxe.stringify(expr6) + '.' + GenHaxe.rename(name16)
				}

				case 25: {
					let data.Node.TNew(_, _, _, values) = node
					let data.Node.TNew(_, _, names, _) = node
					let data.Node.TNew(_, args, _, _) = node
					let data.Node.TNew(t9, _, _, _) = node
					var tmp5: String = 'new ' + GenHaxe.extractTypeName(t9) + '('
					var _g25: [String] = []
					{
						var _g112: Int = 0
						while (_g112 < args.length) {
							var e21: data.Node = args[_g112]
							_g112++
							_g25.push(GenHaxe.stringify(e21))
						}
					}
					tmp = tmp5 + _g25.join(',') + ')'
				}

				case 26: if ({ let data.Node.TArray(value) = node value }.length == 1) {
					if ({ let data.Node.TArray(value) = node value }[0].index == 41) {
						let data.Node.TFor(_, _, expr7) = { let data.Node.TArray(value) = node value }[0]
						let data.Node.TFor(_, array, _) = { let data.Node.TArray(value) = node value }[0]
						let data.Node.TFor(oname1, _, _) = { let data.Node.TArray(value) = node value }[0]
						var f4: data.Node = { let data.Node.TArray(value) = node value }[0]
						GenHaxe.pushScope()
						log.trace(expr7, {fileName: 'GenHaxe.hx', lineNumber: 355, className: 'GenHaxe', methodName: 'stringify'})
						r += '((function(){'
						r += 'var return' + '___' + ' = [];'
						var name17: String = GenHaxe.rename(oname1)
						if (GenHaxe.hasInScope(name17)) name17 += '___' + ++GenHaxe.id
						GenHaxe.addToScope(name17)
						GenHaxe.parentNames.set(expr7, name17)
						GenHaxe.parentNames.set(f4, name17)
						r += 'for(' + name17 + ' in ' + GenHaxe.stringify(array) + ') '
						r += 'return' + '___' + '.push('
						r += GenHaxe.stringify(expr7)
						r += '); return' + '___' + ';'
						r += '})())'
						GenHaxe.popScope()
						tmp = r
					} else {
						let data.Node.TArray(el7) = node
						var _g26: [String] = []
						{
							var _g113: Int = 0
							while (_g113 < el7.length) {
								var e22: data.Node = el7[_g113]
								_g113++
								_g26.push(GenHaxe.stringify(e22))
							}
						}
						tmp = '[' + _g26.join(',') + ']'
					}
				} else {
					let data.Node.TArray(el8) = node
					var _g27: [String] = []
					{
						var _g114: Int = 0
						while (_g114 < el8.length) {
							var e23: data.Node = el8[_g114]
							_g114++
							_g27.push(GenHaxe.stringify(e23))
						}
					}
					tmp = '[' + _g27.join(',') + ']'
				}

				case 27: if ({ let data.Node.TMap(value, _) = node value }.length == 0) tmp = 'new Map()' else {
					let data.Node.TMap(_, values1) = node
					let data.Node.TMap(keys, _) = node
					var _g28: [String] = []
					{
						var _g29: Int = 0
						var _g115: Int = keys.length
						while (_g29 < _g115) {
							var i: Int = _g29++
							_g28.push('' + GenHaxe.stringify(keys[i]) + ' => ' + GenHaxe.stringify(values1[i]) + '')
						}
					}
					tmp = '[' + _g28.join(',') + ']'
				}

				case 28: {
					let data.Node.TIndex(_, index) = node
					let data.Node.TIndex(expr8, _) = node
					tmp = GenHaxe.stringify(expr8) + '[' + GenHaxe.stringify(index) + ']'
				}

				case 29: {
					let data.Node.TSwitch(_, _, cases) = node
					let data.Node.TSwitch(_, conds, _) = node
					let data.Node.TSwitch(exprs, _, _) = node
					r = 'switch ('
					r += GenHaxe.stringify(exprs[0])
					r += ') {\n'
					GenHaxe.tabs += '\t'
					{
						var _g116: Int = 0
						var _g30: Int = cases.length
						while (_g116 < _g30) {
							var i1: Int = _g116++
							var c: data.Node = cases[i1]
							r += GenHaxe.tabs
							{
								var _g210: Int = 0
								var _g32: [data.Node] = conds[i1]
								while (_g210 < _g32.length) {
									var c1: data.Node = _g32[_g210]
									_g210++
									r += 'case ' + GenHaxe.stringify(c1) + ':'
								}
							}
							r += ' {\n'
							r += GenHaxe.tabs + '\t' + GenHaxe.stringify(c) + ';\n'
							r += GenHaxe.tabs + '\t' + '\n' + ('' + GenHaxe.tabs + '}') + '\n'
						}
					}
					GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
					tmp = r + GenHaxe.tabs + '}'
				}

				case 30: {
					let data.Node.TModule(_, el9) = node
					let data.Node.TModule(path, _) = node
					r = 'module ' + path.join('.') + ' {\n'
					GenHaxe.tabs += '\t'
					{
						var _g33: Int = 0
						while (_g33 < el9.length) {
							var e24: data.Node = el9[_g33]
							_g33++
							r += GenHaxe.tabs + GenHaxe.stringify(e24) + ';\n'
						}
					}
					GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
					tmp = r + GenHaxe.tabs + '}'
				}

				case 31: if ({ let data.Node.TObject(value, _) = node value }.length == 0) tmp = '{}' else {
					let data.Node.TObject(_, el10) = node
					let data.Node.TObject(names1, _) = node
					var _g34: [String] = []
					{
						var _g211: Int = 0
						var _g117: Int = el10.length
						while (_g211 < _g117) {
							var i2: Int = _g211++
							_g34.push(GenHaxe.rename(names1[i2]) + ':' + GenHaxe.stringify(el10[i2]))
						}
					}
					tmp = '{' + _g34.join(', ') + '}'
				}

				case 32: {
					let data.Node.TEnum(_, fields2) = node
					let data.Node.TEnum(t10, _) = node
					r = '@:enum abstract ' + GenHaxe.extractTypeName(t10) + '(String)'
					r += ' {\n'
					GenHaxe.tabs += '\t'
					{
						var _g35: Int = 0
						while (_g35 < fields2.length) {
							var f5: data.Node = fields2[_g35]
							_g35++
							switch (f5.index) {
								case 1: {
									let data.Node.TIdent(name18) = f5
									r += GenHaxe.tabs + 'var ' + name18 + ' = {};\n'
								}

								case 8: if ({ let data.Node.TBinop(value, _, _) = f5 value } == 91) {
									if ({ let data.Node.TBinop(_, value, _) = f5 value }.index == 1) {
										let data.Node.TBinop(_, _, val) = f5
										let data.Node.TIdent(name19) = { let data.Node.TBinop(_, value, _) = f5 value }
										r += GenHaxe.tabs + 'var ' + name19 + ' = ' + GenHaxe.stringify(val) + ';\n'
									} else throw new HaxeError('!' + Std.string(f5))
								} else throw new HaxeError('!' + Std.string(f5))
								
								case _: throw new HaxeError('!' + Std.string(f5))
							}
						}
					}
					GenHaxe.tabs = GenHaxe.tabs.substring(0, GenHaxe.tabs.length - 1)
					tmp = r + GenHaxe.tabs + '}'
				}

				case 33: {
					let data.Node.TEnumExtract(_, _, name20) = node
					let data.Node.TEnumExtract(_, extract, _) = node
					let data.Node.TEnumExtract(tenum, _, _) = node
					tmp = '/*tenumxtract*/'
				}

				case 34: {
					let data.Node.TType(_, t11) = node
					let data.Node.TType(name21, _) = node
					tmp = ''
				}

				case 35: {
					let data.Node.TDeclare(_, node1) = node
					let data.Node.TDeclare(name22, _) = node
					if (node1.index == 19) {
						GenHaxe.parentNames.set(node1, name22)
						tmp = '//extern untyped ' + name22
					} else {
						GenHaxe.parentNames.set(node1, name22)
						tmp = '//extern ' + name22
					}
				}

				case 36: {
					let data.Node.TUsing(names2) = node
					tmp = '/*using ' + Std.string(names2) + '*/'
				}

				case 37: {
					let data.Node.TIs(_, t12) = node
					let data.Node.TIs(expr9, _) = node
					tmp = ''
				}

				case 38: {
					let data.Node.TAs(_, _, t13) = node
					let data.Node.TAs(_, kind, _) = node
					let data.Node.TAs(expr10, _, _) = node
					tmp = 'cast (' + GenHaxe.stringify(expr10) + ', ' + GenHaxe.extractTypeName(t13) + ')'
				}

				case 39: tmp = '_'

				case 40: {
					let data.Node.TStatic(field1) = node
					tmp = 'static ' + GenHaxe.stringify(field1)
				}

				case 41: {
					let data.Node.TFor(_, _, b2) = node
					let data.Node.TFor(_, a2, _) = node
					let data.Node.TFor(n3, _, _) = node
					var name23: String = GenHaxe.rename(n3)
					if (GenHaxe.hasInScope(name23)) name23 += ++GenHaxe.id + '___'
					GenHaxe.addToScope(name23)
					GenHaxe.parentNames.set(node, name23)
					tmp = 'for(' + GenHaxe.rename(name23) + ' in ' + GenHaxe.stringify(a2) + ') ' + GenHaxe.stringify(b2)
				}

				case 42: {
					let data.Node.TElvis(_, b3) = node
					let data.Node.TElvis(a3, _) = node
					tmp = '(' + GenHaxe.stringify(a3) + ').or(' + GenHaxe.stringify(b3) + ')'
				}

				case 43: {
					let data.Node.NodeTypeValue(type1) = node
					tmp = GenHaxe.extractTypeName(type1)
				}
			}
			return a + @ast(switch (node) {
				case TEnumExtract(tenum, extract, name): {
					'/*tenumxtract*/'
				}
				case TUsing(names): {
					'/*using $names*/'
				}
				case TVars(e): {
					[for (e in e) stringify(e)].join('; ')
				}
				case TString(s): {
					var s = s.split('')
					var charsOut = []
					while (s.length > 0) {
						switch (s[0]) {
							case '"': {
								charsOut.push('\\"')
								s.shift()
							}
							case '\n': {
								charsOut.push('\\n')
								s.shift()
							}
							case '\r': {
								charsOut.push('\\r')
								s.shift()
							}
							case '\\': {
								s.shift()
								if (s[0] == '"') {
									charsOut.push('\\"')
									s.shift()
								} else {
									charsOut.push('\\')
								}
							}
							case _: {
								charsOut.push(s[0])
								s.shift()
							}
						}
					}
					'"' + charsOut.join('') + '"'
				}
				case TIdent(s): {
					trace('`$s`')
					var source = Project.mapNames.get(node)
					var n = switch (source) {
						case null: {
							throw 'Unmapped $node'
						}
						case TEnum(Type(name), _): {
							name
						}
						case TFor(name, _, _): {
							trace('`$s`')
							parentNames.get(source)
						}
						case TIdent(name): {
							parentNames.get(source)
						}
						case TVar(name, _, _): {
							var n = parentNames.get(source)
							if (n == null) throw 'TVar `$name` parentNames null == ' + parentNames.get(source)
							n
						}
						case TStatic(f = TVar(name, _, _)): {
							var static_source = Project.mapNames.get(source)
							switch (static_source) {
								case TClass(t, _), TEnum(t, _): {
									t.extractTypeName().rename() + '.' + name.rename()
								}
								case _: {
									throw 'static_source is $static_source'
								}
							}
						}
						case TFunction(name, _): {
							name.rename()
						}
						case TClass(t, _): {
							var name = t.extractTypeName().rename()
							var externAtt = getAtt(Project.mapAttributes.get(source), 'extern')
							if (externAtt != null) {
								name
							}
							var rename = getAtt(Project.mapAttributes.get(source), 'native')
							if (rename != null) trace('Got @native!')
							if (rename != null) switch (rename.values[0]) {
								case null: {
									name
								}
								case TString(s): {
									s
								}
								case _: {
									name
								}
							} else name
						}
						case _: {
							throw '$s ' + source
						}
					}
					n
				}
				case TBool(b): {
					'$b'
				}
				case TThis: {
					'this'
				}
				case TSuper: {
					'super'
				}
				case TInt(s): {
					s
				}
				case TFloat(s): {
					s
				}
				case TNull: {
					'null'
				}
				case TBreak: {
					'break'
				}
				case TContinue: {
					'continue'
				}
				case TBinop(op, a, b): {
					a.stringify() + ' ' + op.stringify() + ' ' + b.stringify()
				}
				case TBlock([]): {
					'{}'
				}
				case TBlock(elements): {
					r = '{\n'
					pushScope()
					pushTab()
					for (element in elements) switch (element) {
						case _: {
							var code = tabs + element.stringifyBlockExpression() + ';\n'
							if (!element.match(TBlock(_)) && code.length < 256) trace('Generated block expression `${untyped code.trim()}`')
							r += code
						}
					}
					popTab()
					popScope()
					r + tabs + '}'
				}
				case TElvis(a, b): {
					'(' + a.stringify() + ').or(' + b.stringify() + ')'
				}
				case TFor(n, a, b): {
					var name = n.rename()
					if (hasInScope(name)) name += (++id) + postfix
					addToScope(name)
					parentNames.set(node, name)
					'for(' + name.rename() + ' in ' + a.stringify() + ') ' + b.stringify()
				}
				case TCall(TIdent('__instanceof__'), [of, kind], argNames): {
					'untyped __instanceof__(' + of.stringify() + ', ' + kind.stringify() + ')'
				}
				case TCall(TIdent('require'), [container], argNames): {
					'untyped require(' + container.stringify() + ')'
				}
				case TCall(e, el, argNames): {
					e.stringify() + '(' + [for (e in el) e.stringify()].join(', ') + ')'
				}
				case TParenthesis(e): {
					'(' + e.stringify() + ')'
				}
				case TReturn(null), TReturn(TBlock([])): {
					'return '
				}
				case TReturn(e): {
					'return ' + e.stringify()
				}
				case TThrow(e): {
					'throw ' + e.stringify() + ''
				}
				case TArray([f = TFor(oname, array, expr)]): {
					pushScope()
					trace(expr)
					r += '((function(){'
					r += 'var return$postfix = [];'
					var name = oname.rename()
					if (hasInScope(name)) name += postfix + (++id)
					addToScope(name)
					parentNames.set(expr, name)
					parentNames.set(f, name)
					r += 'for(' + name + ' in ' + array.stringify() + ') '
					r += 'return$postfix.push('
					r += expr.stringify()
					r += '); return$postfix;'
					r += '})())'
					popScope()
					r
				}
				case TArray(el): {
					'[' + [for (e in el) e.stringify()].join(',') + ']'
				}
				case TMap([], _): {
					'new Map()'
				}
				case TMap(keys, values): {
					'[' + [for (i in 0 ... keys.length) '' + keys[i].stringify() + ' => ' + values[i].stringify() + ''].join(',') + ']'
				}
				case TIf(econd, eif, eelse): {
					r = '(' + [for (e in econd) e.stringify()].join(' && ') + ')? (' + eif.stringify()
					if (eelse != null) r += ') : (' + eelse.stringify() + ')'
					r
				}
				case TUnop(op, isPostfix, e): {
					if (isPostfix) e.stringify() + op.stringify() else op.stringify() + e.stringify()
				}
				case TWhile(econd, e, true): {
					'while(' + econd.stringify() + ') ' + e.stringify()
				}
				case TWhile(econd, e, false): {
					'do{' + e.stringify() + '}while(' + econd.stringify() + ')'
				}
				case NodeTypeValue(kind): {
					extractTypeName(kind)
				}
				case TDot(TString(s), 'length'): {
					'' + s.length
				}
				case TDot(expr, name): {
					trace('.`$name`')
					expr.stringify() + '.' + name.rename()
				}
				case TIndex(expr, index): {
					expr.stringify() + '[' + index.stringify() + ']'
				}
				case TIs(expr, t): {
					''
				}
				case TAs(expr, kind, t): {
					'cast (' + expr.stringify() + ', ' + t.extractTypeName() + ')'
				}
				case TFunction(name, expr, vars, _): {
					r = 'function'
					if (name != null) r += ' ' + name.rename()
					r += '(' + [for (v in vars) switch (v) {
						case TIdent(name): {
							parentNames.set(v, name.rename())
							parentNames.get(v)
						}
						case TVar(name, t, e, _): {
							parentNames.set(v, name.rename())
							var code = parentNames.get(v)
							if (t != null && t.extractTypeString().length > 0) code += ': ' + t.extractTypeString().rename()
							if (e != null) code += ' = ' + e.stringify()
							code
						}
						case TParenthesis(null): {
							''
						}
						case _: {
							throw v
						}
					}].join(', ') + ') '
					if (expr != null) {
						switch (expr) {
							case TBlock(el): {
								r += expr.stringify()
							}
							case _: {
								pushScope()
								pushTab()
								r += '{\n$tabs'
								if (name == null) r += 'return '
								r += expr.stringify() + ';\n\t$tabs}'
								popTab()
								popScope()
							}
						}
					} else r += '{}'
					r
				}
				case TVar(oname, t, expr, const): {
					if (oname == null) throw 'name is null for $node'
					var es = ''
					if (expr != null) es = ' = ' + expr.stringify()
					var name = oname.rename()
					if (hasInScope(oname)) {
						name += (++id) + postfix
					}
					addToScope(oname)
					parentNames.set(node, name)
					if (name == null) throw 'name is null for $node'
					r = (if (const) 'var ' else 'var ') + name + es
					r
				}
				case TTry(expr, t, v, catches): {
					r = 'try {\n$tabs\t'
					pushTab()
					switch (expr) {
						case TBlock(el): {
							r += [for (e in el) e.stringifyBlockExpression()].join(';\n' + tabs)
						}
						case _: {
							r += expr.stringify()
						}
					}
					popTab()
					r += '\n' + tabs + '} catch(' + v[0].varName() + ': Any) {\n$tabs\t'
					pushTab()
					parentNames.set(v[0], v[0].varName())
					switch (catches[0]) {
						case TBlock([]): {
							{}
						}
						case TBlock(el): {
							r += [for (e in el) e.stringifyBlockExpression()].join(';\n' + tabs) + ';'
						}
						case _: {
							r += catches[0].stringify()
						}
					}
					popTab()
					r + '\n' + tabs + '}'
				}
				case TNew(t, args, names, values): {
					'new ' + extractTypeName(t) + '(' + [for (e in args) e.stringify()].join(',') + ')'
				}
				case TSwitch(exprs, conds, cases): {
					r = 'switch ('
					r += exprs[0].stringify()
					r += ') {\n'
					pushTab()
					for (i in 0 ... cases.length) {
						var c = cases[i]
						r += tabs
						for (c in conds[i]) r += 'case ' + c.stringify() + ':'
						r += ' {\n'
						r += tabs + '\t' + c.stringify() + ';\n'
						r += tabs + '\t' + '\n' + '$tabs}' + '\n'
					}
					popTab()
					r + tabs + '}'
				}
				case TClass(t, ext, impl, fields, true): {
					var cname = extractTypeName(t)
					var require = getAtt(Project.mapAttributes.get(node), 'require')
					if (require != null) switch [require.values[0], require.values[1]] {
						case [TString(s), null]: {
							r += '@:jsRequire("$s")'
						}
						case [TString(s), TString(f)]: {
							r += '@:jsRequire("$s", "$f")'
						}
						case _: {
							throw '@require takes string as argument'
						}
					}
					r += '/* extern class $cname */'
				}
				case TClass(t, ext, impl, fields, external): {
					var cname = extractTypeName(t)
					r = (if (external) '/* extern class ' else 'class ') + cname
					if (ext != null) r += ' extends ' + extractTypeName(ext)
					r += ' {\n'
					for (f in fields) {
						var code = ''
						var isStatic = false
						function unmeta(f) {
							switch (f) {
								case _: {
									return f
								}
							}
						}
						f = unmeta(f)
						switch (f) {
							case TStatic(field): {
								f = field
								isStatic = true
							}
							case _: {
								{}
							}
						}
						f = unmeta(f)
						pushTab()
						switch (f) {
							case TFunction(name, expr, vars, _): {
								{
									if (name == 'new') {
										code += 'public function new'
									} else if (isStatic) {
										code += 'public static function ' + name.rename()
									} else {
										code += 'public function ' + name.rename()
									}
									code += '(' + [for (v in vars) switch (v) {
										case TVar(name, _, _): {
											var name = name.rename()
											parentNames.set(v, name)
											parentNames.get(v)
										}
										case _: {
											throw v
										}
									}].join(', ') + ') '
									if (expr != null) {
										switch (expr) {
											case TBlock(_): {
												pushTab()
												code += expr.stringify()
												popTab()
											}
											case _: {
												pushTab()
												code += '{\n$tabs' + expr.stringify()
												popTab()
												code += ';\n$tabs}'
											}
										}
									} else code += '{}'
								}
							}
							case TVar(name, t, expr, const): {
								code += 'public static var ' + name.rename()
								if (expr != null) {
									code += ' = ' + expr.stringify()
								}
								code += ';'
							}
							case _: {
								code += '' + f
							}
						}
						code += '\n'
						popTab()
						r += '\t' + code
					}
					r += '' + tabs + '}' + (if (external) ' */' else '')
					r
				}
				case TModule(path, el): {
					r = 'module ' + path.join('.') + ' {\n'
					pushTab()
					for (e in el) {
						r += tabs + e.stringify() + ';\n'
					}
					popTab()
					r + tabs + '}'
				}
				case TObject([], _): {
					'{}'
				}
				case TObject(names, el): {
					'{' + [for (i in 0 ... el.length) names[i].rename() + ':' + el[i].stringify()].join(', ') + '}'
				}
				case TStatic(field): {
					'static ' + field.stringify()
				}
				case TEnum(t, fields): {
					r = '@:enum abstract ' + extractTypeName(t) + '(String)'
					r += ' {\n'
					pushTab()
					for (f in fields) {
						switch (f) {
							case TBinop(OpAssign, TIdent(name), val): {
								r += tabs + 'var ' + name + ' = ' + val.stringify() + ';\n'
							}
							case TIdent(name): {
								r += tabs + 'var ' + name + ' = {};\n'
							}
							case _: {
								throw '!' + f
							}
						}
					}
					popTab()
					r + tabs + '}'
				}
				case TType(name, t): {
					''
				}
				case TUnderscore: {
					'_'
				}
				case TDeclare(name, node): {
					switch (node) {
						case TFunction(_): {
							parentNames.set(node, name)
							'//extern untyped $name'
						}
						case _: {
							parentNames.set(node, name)
							'//extern $name'
						}
					}
				}
			}) tmp
		}

		private static function unwrapBlock(e: data.Node): data.Node {
			if (e.index == 9) {
				if ({ let data.Node.TBlock(value) = e value }.length == 1) {
					var e1: data.Node = { let data.Node.TBlock(value) = e value }[0]
					return e1
				} else {
					let data.Node.TBlock(el) = e
					throw new HaxeError('Unwrapped block has multiple expressions')
				}
			} else return e
		}

		static function extractTypeName(t: data.NodeType): String {
			switch (t.index) {
				case 0: {
					let data.NodeType.Type(name) = t
					return name
				}

				case 1: {
					let data.NodeType.ParamentricType(name1, _) = t
					return name1
				}
				
				case _: throw new HaxeError('Type has no name: ' + Std.string(t))
			}
		}

		static function extractTypeString(t: data.NodeType): String {
			switch (t.index) {
				case 0: {
					let data.NodeType.Type(name) = t
					return name
				}

				case 1: {
					let data.NodeType.ParamentricType(name1, _) = t
					return name1
				}
				
				case _: return ''
			}
		}

		static function generatePackageJson(pack: main.Package): String {
			var jspackage: {author: String, description: String, license: String, main: String, name: String, version: String} = {name: pack.main, version: pack.main, description: pack.description, main: pack.main, author: pack.author, license: pack.license}
			return haxe.json.Json.stringify(jspackage, null, '\t')
		}

		static function stringifyMain(node: data.Node): String {
			var r: String = ''
			var main: String = ''
			GenHaxe.tabs = null
			if (node.index == 9) {
				let data.Node.TBlock(el) = node
				{
					var _g: Int = 0
					while (_g < el.length) {
						var e: data.Node = el[_g]
						_g++
						switch (e.index) {
							case 22, 32, 34: {
								var temptabs: String = GenHaxe.tabs
								GenHaxe.tabs = ''
								GenHaxe.internalTypes.push(GenHaxe.stringifyBlockExpression(e))
								GenHaxe.tabs = temptabs
							}

							case 35: {
								let data.Node.TDeclare(_, source) = e
								let data.Node.TDeclare(name, _) = e
								{
									var temptabs1: String = GenHaxe.tabs
									GenHaxe.tabs = ''
									var externAtt: data.Attribute = GenHaxe.getAtt(data.Project.mapAttributes.get(source), 'extern')
									if (externAtt != null) GenHaxe.internalTypes.push('extern ' + GenHaxe.stringify(source)) else GenHaxe.internalTypes.push('// extern ' + name)
									GenHaxe.stringifyBlockExpression(e)
									GenHaxe.tabs = temptabs1
								}
							}

							case 36: {}
							
							case _: {
								GenHaxe.tabs = if (GenHaxe.tabs == null) '\t\t' else GenHaxe.tabs
								main += '\t\t' + GenHaxe.stringifyBlockExpression(e) + ';\r\n'
							}
						}
					}
				}
			} else throw new HaxeError('' + Std.string(node))
			var currentPackage: String = ''
			if (currentPackage != '') r += 'package ' + currentPackage + ';\r\n'
			r += '\r\nusing Main.__Main__;\r\n\r\n'
			r += 'typedef Any = Dynamic;\r\n\r\n'
			r += GenHaxe.internalTypes.join('\r\n\r\n')
			r += '\r\n\r\nclass __Main__ {\r\n'
			r += '\tstatic function main() {\r\n'
			r += main
			r += '\t}\r\n}\r\n'
			return r
		}

	}
}
