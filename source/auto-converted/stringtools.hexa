module {
	class StringTools {
		@has_untyped
		static function urlEncode(s: String): String {
			return encodeURIComponent(s)
		}

		@has_untyped
		static function urlDecode(s: String): String {
			return decodeURIComponent(s.split('+').join(' '))
		}

		static function htmlEscape(s: String, quotes: Bool?): String {
			s = s.split('&').join('&amp;').split('<').join('&lt;').split('>').join('&gt;')
			if (quotes) return s.split('"').join('&quot;').split('\'').join('&#039;') else return s
		}

		static function htmlUnescape(s: String): String {
			return s.split('&gt;').join('>').split('&lt;').join('<').split('&quot;').join('"').split('&#039;').join('\'').split('&amp;').join('&')
		}

		static function startsWith(s: String, start: String): Bool {
			if (s.length >= start.length) return HxOverrides.substr(s, 0, start.length) == start else return false
		}

		static function endsWith(s: String, end: String): Bool {
			var elen: Int = end.length
			var slen: Int = s.length
			if (slen >= elen) return HxOverrides.substr(s, slen - elen, elen) == end else return false
		}

		static function isSpace(s: String, pos: Int): Bool {
			var c: Int? = HxOverrides.cca(s, pos)
			if (!(c > 8 && c < 14)) return c == 32 else return true
		}

		static function ltrim(s: String): String {
			var l: Int = s.length
			var r: Int = 0
			while (r < l && StringTools.isSpace(s, r)) ++r
			if (r > 0) return HxOverrides.substr(s, r, l - r) else return s
		}

		static function rtrim(s: String): String {
			var l: Int = s.length
			var r: Int = 0
			while (r < l && StringTools.isSpace(s, l - r - 1)) ++r
			if (r > 0) return HxOverrides.substr(s, 0, l - r) else return s
		}

		static function trim(s: String): String {
			return StringTools.ltrim(StringTools.rtrim(s))
		}

		static function lpad(s: String, c: String, l: Int): String {
			if (c.length <= 0) return s
			while (s.length < l) s = c + s
			return s
		}

		static function rpad(s: String, c: String, l: Int): String {
			if (c.length <= 0) return s
			while (s.length < l) s += c
			return s
		}

		static function replace(s: String, sub: String, by: String): String {
			return s.split(sub).join(by)
		}

		static function hex(n: Int, digits: Int?): String {
			var s: String = ''
			var hexChars: String = '0123456789ABCDEF'
			while (true) {
				s = hexChars.charAt(n & 15) + s
				n >>>= 4
				if (!(n > 0)) break
			}
			if (digits != null) while (s.length < digits) s = '0' + s
			return s
		}

		@has_untyped
		static function fastCodeAt(s: String, index: Int): Int {
			return s.charCodeAt(index)
		}

		@noUsing
		static function isEof(c: Int): Bool {
			return c != c
		}

		static function quoteUnixArg(argument: String): String {
			if (argument == '') return '\'\''
			if (!new EReg('[^a-zA-Z0-9_@%+=:,./-]', '').match(argument)) return argument
			return '\'' + StringTools.replace(argument, '\'', '\'"\'"\'') + '\''
		}

		static var winMetaCharacters: [Int] = {[32, 40, 41, 37, 33, 94, 34, 60, 62, 38, 124, 10, 13, 44, 59]}
		static function quoteWinArg(argument: String, escapeMetaCharacters: Bool): String {
			if (!new EReg('^[^ \t\\\\"]+$', '').match(argument)) {
				var result_b: String = ''
				var needquote: Bool = argument.indexOf(' ') != -1 || argument.indexOf('\t') != -1 || argument == ''
				if (needquote) result_b += '"'
				var bs_buf: StringBuf = new StringBuf()
				{
					var _g1: Int = 0
					var _g: Int = argument.length
					while (_g1 < _g) {
						var i: Int = _g1++
						{
							var _g2: Int? = HxOverrides.cca(argument, i)
							if (_g2 == null) {
								var c: Int? = _g2
								{
									if (bs_buf.b.length > 0) {
										result_b += Std.string(bs_buf.b)
										bs_buf = new StringBuf()
									}
									result_b += String.fromCharCode(c)
								}
							} else switch (_g2) {
								case 34: {
									var bs: String = bs_buf.b
									result_b += if (bs == null) 'null' else '' + bs
									result_b += if (bs == null) 'null' else '' + bs
									bs_buf = new StringBuf()
									result_b += '\\"'
								}

								case 92: bs_buf.b += '\\'
								
								case _: {
									var c1: Int? = _g2
									{
										if (bs_buf.b.length > 0) {
											result_b += Std.string(bs_buf.b)
											bs_buf = new StringBuf()
										}
										result_b += String.fromCharCode(c1)
									}
								}
							}
						}
					}
				}
				result_b += Std.string(bs_buf.b)
				if (needquote) {
					result_b += Std.string(bs_buf.b)
					result_b += '"'
				}
				argument = result_b
			}
			if (escapeMetaCharacters) {
				var result_b1: String = ''
				{
					var _g11: Int = 0
					var _g3: Int = argument.length
					while (_g11 < _g3) {
						var i1: Int = _g11++
						var c2: Int? = HxOverrides.cca(argument, i1)
						if (StringTools.winMetaCharacters.indexOf(c2) >= 0) result_b1 += '^'
						result_b1 += String.fromCharCode(c2)
					}
				}
				return result_b1
			} else return argument
		}

	}
}
