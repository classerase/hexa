module haxe.ds.balancedtree {
	class BalancedTree< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > {
		private var root: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >
		function set(key: haxe.ds.balancedtree.K, value: haxe.ds.balancedtree.V): Void {
			this.root = this.setLoop(key, value, this.root)
		}

		function get(key: haxe.ds.balancedtree.K): haxe.ds.balancedtree.V? {
			var node: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > = this.root
			while(node != null) {
				var c: Int = this.compare(key, node.key)
				if(c == 0) return node.value
				if(c < 0) node = node.left else node = node.right
			}
			return null
		}

		function remove(key: haxe.ds.balancedtree.K): Bool {
			try {
				this.root = this.removeLoop(key, this.root)
				return true
			} catch(e:String) {
				return false
			}
		}

		function exists(key: haxe.ds.balancedtree.K): Bool {
			var node: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > = this.root
			while(node != null) {
				var c: Int = this.compare(key, node.key)
				if(c == 0) return true else if(c < 0) node = node.left else node = node.right
			}
			return false
		}

		function iterator(): stdtypes.Iterator< haxe.ds.balancedtree.V > {
			var ret: [haxe.ds.balancedtree.V] = {[]}
			this.iteratorLoop(this.root, ret)
			return HxOverrides.iter(ret)
		}

		function keys(): stdtypes.Iterator< haxe.ds.balancedtree.K > {
			var ret: [haxe.ds.balancedtree.K] = {[]}
			this.keysLoop(this.root, ret)
			return HxOverrides.iter(ret)
		}

		private function setLoop(k: haxe.ds.balancedtree.K, v: haxe.ds.balancedtree.V, node: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >): haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > {
			if(node == null) return new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(null, k, v, null)
			var c: Int = this.compare(k, node.key)
			if(c == 0) return new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(node.left, k, v, node.right, if(node == null) 0 else node._height) else if(c < 0) {
				var nl: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > = this.setLoop(k, v, node.left)
				return this.balance(nl, node.key, node.value, node.right)
			} else {
				var nr: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > = this.setLoop(k, v, node.right)
				return this.balance(node.left, node.key, node.value, nr)
			}
		}

		private function removeLoop(k: haxe.ds.balancedtree.K, node: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >): haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > {
			if(node == null) throw new HaxeError('Not_found')
			var c: Int = this.compare(k, node.key)
			if(c == 0) return this.merge(node.left, node.right) else if(c < 0) return this.balance(this.removeLoop(k, node.left), node.key, node.value, node.right) else return this.balance(node.left, node.key, node.value, this.removeLoop(k, node.right))
		}

		private function iteratorLoop(node: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >, acc: [haxe.ds.balancedtree.V]): Void {
			if(node != null) {
				this.iteratorLoop(node.left, acc)
				acc.push(node.value)
				this.iteratorLoop(node.right, acc)
			}
		}

		private function keysLoop(node: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >, acc: [haxe.ds.balancedtree.K]): Void {
			if(node != null) {
				this.keysLoop(node.left, acc)
				acc.push(node.key)
				this.keysLoop(node.right, acc)
			}
		}

		private function merge(t1: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >, t2: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >): haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > {
			if(t1 == null) return t2
			if(t2 == null) return t1
			var t: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > = this.minBinding(t2)
			return this.balance(t1, t.key, t.value, this.removeMinBinding(t2))
		}

		private function minBinding(t: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >): haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > {
			if(t == null) throw new HaxeError('Not_found') else if(t.left == null) return t else return this.minBinding(t.left)
		}

		private function removeMinBinding(t: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >): haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > {
			if(t.left == null) return t.right else return this.balance(this.removeMinBinding(t.left), t.key, t.value, t.right)
		}

		private function balance(l: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >, k: haxe.ds.balancedtree.K, v: haxe.ds.balancedtree.V, r: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >): haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > {
			var hl: Int = if(l == null) 0 else l._height
			var hr: Int = if(r == null) 0 else r._height
			if(hl > hr + 2) {
				var _this: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > = l.left
				var _this1: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > = l.right
				if((if(_this == null) 0 else _this._height) >= (if(_this1 == null) 0 else _this1._height)) return new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(l.left, l.key, l.value, new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(l.right, k, v, r)) else return new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value, new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(l.right.right, k, v, r))
			} else if(hr > hl + 2) {
				var _this2: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > = r.right
				var _this3: haxe.ds.balancedtree.TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V > = r.left
				if((if(_this2 == null) 0 else _this2._height) > (if(_this3 == null) 0 else _this3._height)) return new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(l, k, v, r.left), r.key, r.value, r.right) else return new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(l, k, v, r.left.left), r.left.key, r.left.value, new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(r.left.right, r.key, r.value, r.right))
			} else return new TreeNode< haxe.ds.balancedtree.K, haxe.ds.balancedtree.V >(l, k, v, r, (if(hl > hr) hl else hr) + 1)
		}

		private function compare(k1: haxe.ds.balancedtree.K, k2: haxe.ds.balancedtree.K): Int {
			return Reflect.compare(k1, k2)
		}

		function toString(): String {
			if(this.root == null) return '{}' else return '{' + this.root.toString() + '}'
		}

		new() {}
	}
}
