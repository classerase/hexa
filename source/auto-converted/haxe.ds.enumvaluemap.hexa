module haxe.ds.enumvaluemap {
	class EnumValueMap< haxe.ds.enumvaluemap.K, haxe.ds.enumvaluemap.V > extends haxe.ds.balancedtree.BalancedTree< haxe.ds.enumvaluemap.K, haxe.ds.enumvaluemap.V > implements haxe.constraints.IMap< haxe.ds.enumvaluemap.K, haxe.ds.enumvaluemap.V > {
		private function compare(k1: EnumValue, k2: EnumValue): Int {
			var d: Int = k1[1] - k2[1]
			if(d != 0) return d
			var p1: [Any] = k1.slice(2)
			var p2: [Any] = k2.slice(2)
			if(p1.length == 0 && p2.length == 0) return 0
			return this.compareArgs(p1, p2)
		}

		private function compareArgs(a1: [Any], a2: [Any]): Int {
			var ld: Int = a1.length - a2.length
			if(ld != 0) return ld
			{
				var _g1: Int = 0
				var _g: Int = a1.length
				while(_g1 < _g) {
					var i: Int = _g1++
					var d: Int = this.compareArg(a1[i], a2[i])
					if(d != 0) return d
				}
			}
			return 0
		}

		private function compareArg(v1: Any, v2: Any): Int {
			if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) return this.compare(v1, v2) else if(__instanceof__(v1, Array) && v1.__enum__ == null && (__instanceof__(v2, Array) && v2.__enum__ == null)) return this.compareArgs(v1, v2) else return Reflect.compare(v1, v2)
		}

		new() {
			super()
		}
	}
}
