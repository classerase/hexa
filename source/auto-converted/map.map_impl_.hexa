module map {
	@final
	private class Map_Impl_ {
		@extern
		@impl
		static function _new(): [map.K:map.V]
		@impl
		static function set(this1: map.IMap< map.K, map.V >, key: map.K, value: map.V): Void {
			this1.set(key, value)
		}

		@impl
		@arrayAccess
		static function get(this1: map.IMap< map.K, map.V >, key: map.K): map.V? {
			return this1.get(key)
		}

		@impl
		static function exists(this1: map.IMap< map.K, map.V >, key: map.K): Bool {
			return this1.exists(key)
		}

		@impl
		static function remove(this1: map.IMap< map.K, map.V >, key: map.K): Bool {
			return this1.remove(key)
		}

		@impl
		static function keys(this1: map.IMap< map.K, map.V >): stdtypes.Iterator< map.K > {
			return this1.keys()
		}

		@impl
		static function iterator(this1: map.IMap< map.K, map.V >): stdtypes.Iterator< map.V > {
			return this1.iterator()
		}

		@impl
		static function toString(this1: map.IMap< map.K, map.V >): String {
			return this1.toString()
		}

		@impl
		@arrayAccess
		@noCompletion
		static function arrayWrite(this1: map.IMap< map.K, map.V >, k: map.K, v: map.V): map.V {
			this1.set(k, v)
			return v
		}

		@impl
		@to
		private static function toStringMap(t: map.IMap< map.K, map.V >): haxe.ds.stringmap.StringMap< map.V > {
			return new StringMap< map.V >()
		}

		@impl
		@to
		private static function toIntMap(t: map.IMap< map.K, map.V >): haxe.ds.intmap.IntMap< map.V > {
			return new IntMap< map.V >()
		}

		@impl
		@to
		private static function toEnumValueMapMap(t: map.IMap< map.K, map.V >): haxe.ds.enumvaluemap.EnumValueMap< map.K, map.V > {
			return new EnumValueMap< map.K, map.V >()
		}

		@impl
		@to
		private static function toObjectMap(t: map.IMap< map.K, map.V >): haxe.ds.objectmap.ObjectMap< map.K, map.V > {
			return new ObjectMap< map.K, map.V >()
		}

		@from
		private static function fromStringMap(map: haxe.ds.stringmap.StringMap< map.V >): [String:map.V] {
			return (map as! [String:map.V])
		}

		@from
		private static function fromIntMap(map: haxe.ds.intmap.IntMap< map.V >): [Int:map.V] {
			return (map as! [Int:map.V])
		}

		@from
		private static function fromObjectMap(map: haxe.ds.objectmap.ObjectMap< map.K, map.V >): [map.K:map.V] {
			return (map as! [map.K:map.V])
		}

	}
}
