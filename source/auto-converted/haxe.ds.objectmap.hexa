module haxe.ds.objectmap {
	@coreApi
	class ObjectMap< K, V > implements haxe.constraints.IMap< K, V > {
		private var h: {:}
		@has_untyped
		function set(key: K, value: V): Void {
			var id: Int = key.__id__ || (key.__id__ = ++haxe.ds.objectmap.ObjectMap.count)
			this.h[id] = value
			this.h.__keys__[id] = key
		}

		@has_untyped
		function get(key: K): V? {
			return this.h[key.__id__]
		}

		@has_untyped
		function exists(key: K): Bool {
			return this.h.__keys__[key.__id__] != null
		}

		@has_untyped
		function remove(key: K): Bool {
			var id: Int = key.__id__
			if (this.h.__keys__[id] == null) return false
			__js__('delete')(this.h[id])
			__js__('delete')(this.h.__keys__[id])
			return true
		}

		@has_untyped
		function keys(): stdtypes.Iterator< K > {
			var a: [K] = []
			{
				__js__('for( var key in this.h.__keys__ ) {')
				if (this.h.hasOwnProperty(key)) a.push(this.h.__keys__[key])
				__js__('}')
			}
			return HxOverrides.iter(a)
		}

		@has_untyped
		function iterator(): stdtypes.Iterator< V > {
			return {ref: this.h, it: this.keys(), hasNext: function(): Bool {
				return this.it.hasNext()
			}, next: function(): V {
				var i: {:} = this.it.next()
				return this.ref[i.__id__]
			}}
		}

		function toString(): String {
			var s_b: String = ''
			s_b += '{'
			var it: stdtypes.Iterator< K > = this.keys()
			{
				var i: stdtypes.Iterator< K > = it
				while (i.hasNext()) {
					var i1: K = i.next()
					s_b += Std.string(Std.string(i1))
					s_b += ' => '
					s_b += Std.string(Std.string((this.h[i1.__id__] as! V?)))
					if (it.hasNext()) s_b += ', '
				}
			}
			s_b += '}'
			return s_b
		}

		private static var count: Int = 0
		@has_untyped
		private static function assignId(obj: {:}): Int {
			return obj.__id__ = ++haxe.ds.objectmap.ObjectMap.count
		}

		@has_untyped
		private static function getId(obj: {:}): Int {
			return obj.__id__
		}

		new() {
			this.h = {__keys__: {:}}
		}
	}
}
