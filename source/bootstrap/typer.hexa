// The Hexa Compiler
// Copyright (C) 2018  Oleg Petrenko
// Copyright (C) 2018  Bogdan Danylchenko
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

module {
	// Fills type information, checks for errors
	class Typer {
		new () {}
		function fillScopes(collected: Node) {
		// Modularity

		var namespaces: [String : Node] = [:]

		function nameOfModuleItem(node: Node): String {
			switch (node) {
				case Node.TVar(name, _): return name
				case Node.TFunction(name, _):
					if (let named = name) return named
					else throw 'Module function should have a name'
				case Node.TPrivate(node): switch (node) {
					case Node.TClass(t, _): switch (t) {
						case NodeType.Type(name): return name
						case NodeType.ParametricType(name): return name
					}
				}
				case Node.TClass(t, _): switch (t) {
					case NodeType.Type(name): return name
					case NodeType.ParametricType(name): return name
				}
				case Node.TEnum(t, _): switch (t) {
					case NodeType.Type(name): return name
					case NodeType.ParametricType(name): return name
				}
				case Node.TDeclare(name, _): return name
				case _: throw 'Improper module item format ' + TestParser.stringify(node)
			}
		}

		function fillModuleNamespace(m: Node) {
			var el = null
			var root: String? = null
			switch (m) {
				case Node.TModule(path, els):
				el = els
				root = path.join('.')
				case _: throw 'Unreachable #2'
			}

			if (namespaces[root] == null) {
				namespaces[root] = m
			} else {
				var els = null
				switch (namespaces[root]) {
					case Node.TModule(_, el): els = el
					case _: throw 'Unreachable #1'
				}
				while (el.length > 0) els.push(el.pop())
			}

			{
				var els = null
				switch (namespaces[root]) {
					case Node.TModule(_, el): els = el
					case _: throw 'Unreachable #4'
				}

				for (e in els) {
					var name = nameOfModuleItem(e)
					var found = false
					for (e in els) {
						if (nameOfModuleItem(e) == name) {
							if (found) throw ('Type `\(name)` already exists in module')
							if (!found) found = true
						}
					}
				}
			}
		}

		// Let's fill global namespaces first to avoid delayed expansion
		for (file in collected) {
			var didInit = false
			for (e in file) switch (e) {
				case Node.TModule(path, el):
					if (didInit) throw 'Modules should follow before expressions'
					fillModuleNamespace(e)
				case _:
					didInit = true
			}
		}

		var intermediate = []

		// Fill intermediate non-existsing modules (module aaa.not_exists.bbb {})
		{
			var intermediateSubs = []
			for (ns in namespaces.keys()) {
				var path = ns.split('.')
				var namespace = path.shift()
				function check(namespace) {
					if (namespaces[namespace] == null && intermediate.indexOf(namespace) == -1) {
						intermediate.push(namespace)
					}
				}
				check(namespace)
				while (path.length > 0) {
					namespace += '.' + path.shift()
					check(namespace)
				}
			}

			//if (intermediate.length >0 ) throw '' + intermediate + ' subs:' + intermediateSubs

			for (path in intermediate) {
				var m = Node.TModule(path.split('.'), [])
				namespaces[path] = m
			}
		}

		function findInNamespaceRoots(name: String): Node {
			if (namespaces[name] != null) return namespaces[name]
			var m = namespaces['']
			var el = null
			switch (m) {
				case Node.TModule(_, els): el = els
				case _: return null // No root
			}
			for (e in el) if (name == nameOfModuleItem(e)) return e
			// TODO module{a} conflicts to module a {}, otherwise merge those globals
		// TODO intermediate non-existsing modules (module aaa.not_exists.bbb {})
			return null//namespaces[''][name]
		}

		var scopes: [[String : Node]] = [[:]]
		var currentClass: [Node] = []
		var prevnode = null
		var isInExternalClass = false

		function pushScope() scopes.push(new Map())
		function popScope() scopes.pop()
		function addScope(name, node)
			scopes[scopes.length-1].set(name, node)

		function fail(msg: String, node: Node = null) {
			var data = Project.data.get(node)
			if (data == null)
				data = Project.data.get(prevnode)
				if (data == null) {
					return new CompilerError(Fail.TyperError, msg, 0, 0, "")
				}
			return new CompilerError(Fail.TyperError, msg, data.line, data.column, data.fileName)
		}
		var prevnode_s = null

		function findName(name) {

		}


		var functionAllowedToThrow = false // @noThrow is *not* set
		var functionThrows = false // `throw` is happened
		var insideTry = false // `try { insideTry } catch (...) { ... }`
		var insideFunction = false // `function () { insideFunction }`
		var insideClassMethod = false // `class T { function () { insideClassMethod } }` non-static!
		var allowSuper = false // `class T extends C { function () { super() } }` non-static!
		var allowBreakAndContinue = false // Used in loops

		function fill(node: Node) {
			prevnode = node
			switch (node) {
				// TODO Fill TEnumExtract
				case Node.TEnumExtract(path, bind, expr): {
					for (e in bind) switch (e) {
						case null: {} // _
						case Node.TVar(name, _): addScope(name, e)
						case _: throw 'TEnumExtract contains not a var: ' + e
					}
					if (DataHelper.isVoidValue(expr)) throw fail('There should be a non-void value instead of ', expr)
					fill(expr)
				}
				case Node.TVars(e): for (ee in e) fill(ee)
				case Node.TBlock(el):
					pushScope()
					for (e in el) fill(e)
					popScope()
				case Node.TIdent(name):
					//if (name == 's')
					//	if (prevnode_s == null) {
					//		prevnode_s = node
					//	} else {
					//		//throw('== \(prevnode_s == node) "\(name)" \(prevnode_s) \(node), \(Project.mapNames[node])')
					//	}
					var subj = null
					for (i in scopes.length) {
						subj = scopes[scopes.length - i - 1].get(name)
						if (subj != null) {
							//Project.mapNames[node] = subj
							break
						}
					}

					if (subj == null) subj = findInNamespaceRoots(name)
					if (subj == null)
						throw fail('Cannot find name `\(name)` for \(node)', node)
					if (Project.mapNames.get(node) != null && Project.mapNames.get(node) != subj)
						throw fail('mapNames overwitten from \(Project.mapNames.get(node)) to \(subj) for node \(node)', node)
					Project.mapNames.set(node, subj)

					switch (subj) {
						case Node.TVar(_):
						case _:
					}

					//Project.mapNames[node] = scopes[scopes.length-1][name]
				case Node.TUsing(names): {}

				//case TVar(name = 'valueg',t,e,c): throw fail('' + name+' ' + t + ' ' + e + ' ' + c, node)



				// TODO Hexa case TVar(name,_,TBlock([..., TVar(name2,_)]),_):




				case Node.TVar(name, t, e, const):
					if (e == null && const)
						throw fail('Constant should have a value `let \(name) = value`', node)

					if (e != null) {
						// Disallow class as a variable expression
						switch (e) {
							case Node.TClass(_, _, _, _, _):
								throw fail('Variable should not have class as a value', node)
							case _:
						}
						if (DataHelper.isVoidValue(e))
							throw fail('Cannot assign var to a void `var \(name) = void`', node)
						fill(e)
					}

					addScope(name, node)

				case Node.TArray(el): for (e in el) fill(e)
				case Node.TMap(keys, values):
					for (i in keys.length) {
						fill(keys[i])
						fill(values[i])
					}
				case Node.TAs(e, kind, t):
					fill(e)
				// Constant `let`s
				case Node.TAssignop(a, op, b):
					if (DataHelper.isVoidValue(b)) throw fail('Cannot use void as value', node)
					fill(a)
					var parent: Node = Project.mapNames.get(a)
					switch (parent) {
						case Node.TVar(name, _, _, const):
							if (const)
							throw fail('Cannot reassign a constant `\(name)`', node)
						case Node.TFunction(name, _):
							throw fail('Cannot reassign a function `\(name)`', node)
						case _: // Ok
					}
					fill(b)

				case Node.TBinop(a, op, b):
					if (DataHelper.isVoidValue(a)) throw fail('Cannot use void as assignee', node)
					if (DataHelper.isVoidValue(b)) throw fail('Cannot use void as value', node)
					fill(a)
					fill(b)

					var parent: Node = Project.mapNames.get(a)
					if (op == Token.OpAssign) switch (parent) {
						case Node.TVar(name, _, _, const):
							if (const)
								throw fail('Cannot reassign a constant `\(name)`', node)
						case Node.TFunction(name, _):
							throw fail('Cannot reassign a function `\(name)`', node)
						case _: // Ok
					}

					switch (node) {
						case _: // Ok
					}
				case Node.TBreak:
					if (!allowBreakAndContinue) throw fail('Cannot use `break` outside of loop', node)
				case Node.TCall(e, el, elNames):
					switch (e) {
						case Node.TSuper(_):
							if (!allowSuper) throw fail('Cannot access `super` here', node)
							Project.mapNames.set(node, currentClass[currentClass.length - 1])
						case _:
							fill(e)
					}
					for (e in el) {
						if (DataHelper.isVoidValue(e)) throw fail('Cannot use void as argument value', node)
						fill(e)
					}

				case Node.TClass(t, ex, i, f, external):
					allowSuper = false
					var iiec = isInExternalClass
					isInExternalClass = external
					var name = extractTypeName(t)
					addScope(name, node)
					currentClass.push(node)
					pushScope()
					// Fill class scope, also check for existence of field
					for (field in f) {
						var name = null
						switch (field) {
							case Node.TVar(fname, _): name = fname
							case Node.TFunction(fname, _):
							if (fname == null) name = 'new'
							else name = fname
							case Node.TStatic(f): switch (f) {
								case Node.TVar(fname, _): name = fname
								case Node.TFunction(fname, _): name = fname
							}
							case _:
								throw fail('Incorrect class field node: \(field)', node)
						}
						let map = scopes[scopes.length - 1]
						if (map.has(name))
							throw fail('Class field `\(name)` already exists', node)
						map.set(name, field)

						Project.mapNames.set(field, node)
					}

					// Fill expressions
					for (field in f) {
						switch (field) {
							case Node.TFunction(_, e, v, r):
							allowSuper = (ex != null)
							insideClassMethod = true
							if (e != null) fill(Node.TFunction(null, e, v, r))
							insideClassMethod = false
							allowSuper = false

							case Node.TVar(vname, t, e, _):
								if (e != null) fill(e)

							case Node.TStatic(e):
							switch (e) {
								case Node.TFunction(_, e, v, r):
								if (e != null) fill(Node.TFunction(null, e, v, r))
								case Node.TVar(_, _, e, _):
								if (e != null) fill(e)
							}
							case _: {}
						}
					}

					popScope()
					currentClass.pop()
					isInExternalClass = iiec

				case Node.TDeclare(name, vnode):
					switch (vnode) {
						case Node.TVar(vname, t, expr, const):
							if (const && expr == null) addScope(name, node)

						case Node.TFunction(fname, expr, vars, rettype):
							addScope(name, node)
							addScope(name, vnode)

						case _: addScope(name, node) fill(vnode)
					}

				case Node.TDot(e, n):
					switch (e) {
						case Node.TSuper(_):
							if (!allowSuper) throw fail('Cannot access `super` here', node)
							Project.mapNames.set(node, currentClass[currentClass.length - 1])
						case _:
							fill(e)
					}

				case Node.TElvis(a, b): fill(a) fill(b)
				case Node.TEnum(t, f, valuesType):
					var name = extractTypeName(t)
					addScope(name, node)

					// Fill expressions
					for (field in f) {
						switch (field) {
							case Node.TStatic(e): switch (e) {
								case Node.TFunction(_, e, v, r):
									if (e != null) fill(Node.TFunction(null, e, v, r))
							}
							case Node.TFunction(_, e, v, r):
								if (e != null) fill(Node.TFunction(null, e, v, r))
							case _: {}
						}
					}
				case Node.TFor(name, over, by):
					if (DataHelper.isVoidValue(over)) throw fail('Cannot use void as value', node)
					pushScope()
					fill(over)
					addScope(name, node)
					let _allowBreakAndContinue = allowBreakAndContinue
					allowBreakAndContinue = true
					fill(by)
					allowBreakAndContinue = _allowBreakAndContinue
					popScope()

				case Node.TFunction(name, expr, vars, rettype):
					// Save stack
					let _functionAllowedToThrow = functionAllowedToThrow
					let _functionThrows = functionThrows
					let _insideFunction = insideFunction
					let _insideTry = insideTry

					// Reset stack
					if (let noThrow = DataHelper.getAttribute(Project.mapAttributes.get(node), 'noThrow')) {
						if (noThrow.values.length > 0) throw fail('Attribute `@noThrow` should have no parameters', node)
						functionAllowedToThrow = false
					} else functionAllowedToThrow = true

					if (let throws = DataHelper.getAttribute(Project.mapAttributes.get(node), 'throws')) {
						if (functionAllowedToThrow == false) throw fail('Attribute `@noThrow` cannot be used with `@throws`', node)
						functionThrows = true
					} else functionThrows = false

					insideTry = false
					insideFunction = true

					if (expr == null && !isInExternalClass) throw fail('Non-external function should have a body', node)
					if (name != null) addScope(name, node)
					pushScope()
					for (i in vars.length) {
						let v = vars[i]
						switch (v) {
							case Node.TVar(vname, _, _): addScope(vname, v)
							case Node.TIdent(vname): addScope(vname, v)
							case Node.TParenthesis(e): if (e != null) throw fail(v + '', node)
							case _:
								throw fail(v + '', node)
						}
					}
					if (expr != null) fill(expr)
					popScope()

					// Restore stack
					functionAllowedToThrow = _functionAllowedToThrow
					functionThrows = _functionThrows
					insideTry = _insideTry
					insideFunction = _insideFunction

				case Node.TArrow(expr, vars, rettype):
					if (expr == null && !isInExternalClass) throw fail('Arrow function should have a body', node)
					pushScope()
					for (v in vars) {
						switch (v) {
							case Node.TVar(vname, t, _):
								addScope(vname, v)
							case Node.TIdent(vname): addScope(vname, v)
							case Node.TParenthesis(e): if (e != null) throw fail(v + '', node)
							case _:
								throw fail(v + '', node)
						}
					}

					// Save stack
					let _insideFunction = insideFunction
					// Reset stack
					insideFunction = true

					fill(expr)
					popScope()

					// Restore stack
					insideFunction = _insideFunction

				case Node.TIf(econd, eif, eelse):
					var depth = 0
					for (e in econd) {
						switch (e) {
							case Node.TVar(_, t, _, const):
								if (!const) throw fail('Only if-let bindings supported', node)
								depth++
								pushScope()
								fill(e)
							case _:
								fill(e)
						}
					}
					fill(eif)
					while (depth > 0) {
						depth--
						popScope()
					}

					if (eelse != null) fill(eelse)

				//case TIf(econd, eif, null):
				//	for (e in econd) fill(e) fill(eif)
				//case TIf(econd, eif, eelse):
				//	for (e in econd) fill(e) fill(eif) fill(eelse)
				case Node.TIndex(e, i): fill(e) fill(i)

				//case TModule(_, null): throw 'Modules should be at a file\' upper scope'
				//case TModule(el): throw 'Modules should be at a file\' upper scope'
				case Node.TModule: throw fail('Modules should be at a file\' upper scope', node)

				//TODO vames and values added

				case Node.TNew(path, t, el, names, values):
					// TODO parent names and path check
					for (e in el) fill(e)
				case Node.TObject(names, el): for (e in el) fill(e)
				case Node.TParenthesis(e):
					fill(e)
				case Node.TReturn(e):
					if (!insideFunction) throw fail('Cannot use `return` outside of function', node)
					if (e != null && DataHelper.isVoidValue(e)) throw fail('Cannot use void as a returning value', node)
					if (e != null) fill(e)
				case Node.TStatic(e):
					throw fail('Cannot use `static` here', node)
				case Node.TSuper:
					throw fail('Cannot use `super` as value', node)
				case Node.TThis:
					if (!insideClassMethod) throw fail('Cannot access `this` outside of class method', node)
					Project.mapNames.set(node, currentClass[currentClass.length - 1])
				case Node.TSwitch(exprs, conds, guards, cases): {
					for (e in exprs) { pushScope() fill(e) popScope() }
					var i = 0
					while (i < cases.length) {
						pushScope()
						var e = conds[i]
						// Fill case condition
						function follow(e: Node) {
							switch (e) {
								case Node.TDot(ex, name): {fill(e)}
								case Node.TParenthesis(e): {fill(e)}
								case Node.TUnderscore: {}
								case Node.TNull: {}
								case Node.TBool(_): {}
								case Node.TInt(_): {}
								case Node.TString(_): {}
								case Node.TCall(ex, args, argNames): {
									follow(ex)
									for (ee in args) follow(ee)
								}
								case Node.TIdent(name): // bind var
								{
									if (name.charAt(0) == name.charAt(0).toUpperCase()) {fill(e)}
									else {
										addScope(name, e)
									}
								}
								case Node.TBinop(a, op, b):
								if (op == Token.OpOr) {follow(a) follow(b)}
								else throw fail('' + e, e)
								case Node.TIf(econd, _, _):
									pushScope()
									fill(econd[0])
									popScope()
								case _:
									throw fail('' + e, e)
							}
						}
						follow(e)

						// Fill case result expression
						var e = cases[i]
						pushScope() fill(e) popScope()
						popScope()
						i++
					}
				}
				case Node.TThrow(e):
					if (!insideFunction && !insideTry)
						throw fail('Cannot throw outside of `function` or `try`', node)
					if (insideFunction && !functionAllowedToThrow)
						throw fail('Cannot throw in a @noThrow function', node)
					if (insideFunction)
						functionThrows = true // Infer that function throws
					// TODO handle types

					fill(e)
				case Node.TTry(e, t, v, ca):
					let _insideTry = insideTry
					insideTry = true
					fill(e)
					insideTry = _insideTry

					for (i in ca.length) {
						pushScope()
						scopes[scopes.length - 1].set(DataHelper.varName(v[i]), v[i])
						fill(ca[i])
						popScope()
					}
				case Node.TUnop(_, _, e): fill(e)
				case Node.TWhile(econd, e, pre):
					fill(econd)
					let _allowBreakAndContinue = allowBreakAndContinue
					allowBreakAndContinue = true
					fill(e)
					allowBreakAndContinue = _allowBreakAndContinue

				case Node.TIs(expr, t):
				case Node.NodeTypeValue(t):
				case Node.TUnderscore: {}
				case Node.TNull: {}
				case Node.TBool(_): {}
				case Node.TInt(_): {}
				case Node.TFloat(_): {}
				case Node.TContinue:
					if (!allowBreakAndContinue) throw fail('Cannot use `continue` outside of loop', node)
				case Node.TExport(f): fill(f)
				case Node.TString(s):
					// Validate escape sequences
					let allowedEscapes = ['\\', 'n', 'r', 't', '"', "'", 'x']
					var i = 0
					while (i < s.length) if (s.charAt(i) == '\\') {
						if (allowedEscapes.indexOf(s.charAt(i + 1)) == -1)
							 throw fail('Invalid escape sequence `\\\(s.charAt(i + 1))` in string `\(s)`', node)
						else i += 2
					} else i++
				case Node.TPrivate(_):
					throw fail('Cannot use `private` here', node)
			}
		}

		// Fill module scopes of all files at first
		pushScope()

		for (file in collected) for (e in file) switch (e) {
			case Node.TModule(path, el): for (e in el) fill(e)
			case _:
		}

		popScope()

		// Fill initialization code at files roots
		for (file in collected) {
			pushScope()
			for (e in file) switch (e) {
				case Node.TModule(path, el):
				case _: fill(e)
			}
			popScope()
		}
		}

		// Returns the only name of type
		static function extractTypeName(t: NodeType): String {
			switch (t) {
				case NodeType.Type(name): return name
				case NodeType.ParametricType(name, _): return name
				case _: throw 'Type has no name: ' + t
			}
		}
	}
}
