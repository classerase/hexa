// The Hexa Compiler
// Copyright (C) 2018  Oleg Petrenko
// Copyright (C) 2018  Bogdan Danylchenko
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

module {
class TestParser {
	static function test() {
		Console.log("TestParser begin")


		// Basics and indentaion
		shouldAllEqual([
			''			 : '<!--null-->',
			'  '		 : '<!--null-->',
			'	'		 : '<!--null-->',
			'   	'	 : '<!--null-->',

			'\n'		 : '<!--null-->',
			'\n\n'		 : '<!--null-->',
			'\r\r\n\r\n\r\t' : '<!--null-->',

			'{}' : 'TBlock([])',
			'{{}}' : 'TBlock([TBlock([])])',
			'{ 0 0 0 }' : 'TBlock([TInt(0),TInt(0),TInt(0)])',

			'0' 		 : 'TInt(0)',
			' 0 '		 : 'TInt(0)',
			'123'		 : 'TInt(123)',
			'12'		 : 'TInt(12)',
			"0x1"		 : 'TInt(0x1)',
			"0x0"		 : 'TInt(0x0)',
			"0xF"		 : 'TInt(0xF)',
			"0xFA"		 : 'TInt(0xFA)',
			"0xFABCDEF" : 'TInt(0xFABCDEF)',

			"0.0"		 : 'TFloat(0.0)',
			"0.123" 	 : 'TFloat(0.123)',

			"'s'"		 : 'TString(s)',
			"\"s\"" 	 : 'TString(s)'
		])

		shouldAllEqual([
			'1 2 3 trace("Hello!", "World!") + 5 * 6 / 3':
				'TBlock([
				TInt(1),
				TInt(2),
				TInt(3),
				TBinop(
				TCall(TIdent(trace),[TString(Hello!),TString(World!)]),
				+,
				TBinop(TInt(5),*,TBinop(TInt(6),/,TInt(3))))])',

			'enum Test { Demo } hello World':
				'TBlock([TEnum(Type(Test),[TIdent(Demo)]),
				TIdent(hello),
				TIdent(World)])'
			])

		// Operators
		shouldAllEqual([
			'a + b': "TBinop(TIdent(a),+,TIdent(b))",
			'a += b': "TAssignop(TIdent(a),+,TIdent(b))",
			])

		// String interpolation
		shouldAllEqual([
			// '"\\\\\\(v) \\(v)"'
			])

		shouldAllEqualWithoutTrim([
			])

		// Modularity
		shouldAllEqual([
			'module { class Inner {} }' => 'TModule(,[TClass(Type(Inner),null,[],[],false)])',
			'module { class InnerA {} class InnerB {} }' => 'TModule(,[TClass(Type(InnerA),null,[],[],false),TClass(Type(InnerB),null,[],[],false)])',
			'module m { class C {} enum E {} function f() {} var v }' => "TModule(m,[TClass(Type(C),null,[],[],false),TEnum(Type(E),[]),TFunction(f,TBlock([]),[],null),TVar(v,null,null,false)])",
			'module { }': 'TModule(, [])',
			'code module { } code': 'TBlock([TIdent(code),TModule(,[]),TIdent(code)])',
			'code module { } module { } code': 'TBlock([TIdent(code),TModule(,[]),TModule(,[]),TIdent(code)])',
			'module a { }': 'TModule(a, [])',
			'module a.b { }': 'TModule(a.b, [])',
			'module a { module b { } }': 'TModule(a,[TModule(b,[])])',
			])

		// Types parsing in expressions

		// Types parsing in declarations

		// Enumerations
		shouldAllEqual([
			'enum A {}' : 'TEnum(Type(A),[])',
			])

		// ADTs

		// Constructor
		shouldAllEqual([
			'class A {} var a = new A { } ()' : "TBlock([TClass(Type(A),null,[],[],false),TVar(a,null,TNew([],Type(A),[],[],[]),false)])",
			'class A { var field: String } var a = new A { field: "Value" } ()' :
				"TBlock([TClass(Type(A),null,[],[TVar(field,Type(String),null,false)],false),TVar(a,null,TNew([],Type(A),[],[field],[TString(Value)]),false)])",
			'class A { var field: String var otherfield: Int } var a = new A { field: "Value", otherfield: 25 } ()' :
				"TBlock([TClass(Type(A),null,[],[TVar(field,Type(String),null,false),TVar(otherfield,Type(Int),null,false)],false),TVar(a,null,TNew([],Type(A),[],[field,otherfield],[TString(Value),TInt(25)]),false)])",

			])

		// External declarations
		shouldAllEqual([
			'declare var a: T' : 'TDeclare(a,TVar(a,Type(T),null,false))',
			'declare let a: T' : 'TDeclare(a,TVar(a,Type(T),null,true))',
			'declare function name()' : 'TDeclare(name,TFunction(name,null,[],null))',
			'declare function name() hi()' : 'TBlock([TDeclare(name,TFunction(name,null,[],null)),TCall(TIdent(hi),[])])',
			'declare function name() {}' : 'TBlock([TDeclare(name,TFunction(name,null,[],null)),TBlock([])])',
			])

		shouldAllError([
			"declare var a",
			"declare var a = value",
			"declare var a: T = value",
			"declare function()",
			"declare var a, b, c",
			"declare anything",
			])


		Console.log("TestParser done")
	}

	//
	// Helpers
	//

	// Parses `input` into AST and stringifies, checks by trimmed `test`
	static function shouldEqual(input: String, test: String) {
		let test = TestParser.deepTrim(test)
		shouldEqualWithoutTrim(input, test)
	}

	// Same as `shouldEqual`, but does no trimming of `test`
	static function shouldEqualWithoutTrim(input: String, test: String) {
		//test = "TBlock([" + test	 + "])"
		var lexe = Lexer.tokenize(Buffer.from(input), "TEST")
		var parser = new Parser(lexe)
		var res = stringify(parser.node)
		if (test != res) {
			throw 'TestParser test fail: `\(input)` != `\(test)`\nGot: `\(res)`'
		}
	}

	// Operates `shouldEqual` on all key-vallue pairs of `input => test`
	static function shouldAllEqual(map: Map<String, String>) {
		for (input in map.keys()) {
			var test = map.get(input)
			shouldEqual(input, test)
		}
	}

	// Does `shouldEqual` without triming `=> test` parts
	static function shouldAllEqualWithoutTrim(map: Map<String, String>) {
		for (input in map.keys()) {
			var test = map.get(input)
			shouldEqualWithoutTrim(input, test)
		}
	}

	static function shouldError(input: String) {
		try {
			var lexe = Lexer.tokenize(Buffer.from(input), "TEST")
			var parser = new Parser(lexe)
		}
		catch(e: Any) {
			return
		}
		throw 'TestParser test fail: `\(input)` did not throw exception.'
	}

	static function shouldAllError(input: Array<String>) {
		for (str in input) {
			shouldError(str)
		}
	}


	// Removes all internal and trailing whitespace and newlines
	static function deepTrim(s: String) {
		return s.split('\n').join('').split('\r').join('').split('\t').join('').split(' ').join('')
	}

	// Creates a testable consistent string representation of node
	static function stringify(node: Node): String {
		switch (node) {
		case null: return '<!--null-->'

		// Have no sub-nodes
		case Node.TString(s): return 'TString(\(s))'
		case Node.TIdent(s): return 'TIdent(\(s))'
		case Node.TBool(b): return 'TBool(\(b))'
		case Node.TThis: return 'TThis'
		case Node.TSuper: return 'TSuper'
		case Node.TInt(s): return 'TInt(\(s))'
		case Node.TFloat(s): return 'TFloat(\(s))'
		case Node.TNull: return 'TNull'
		case Node.TBreak: return 'TBreak'
		case Node.TContinue: return 'TContinue'

		// Have sub-nodes
		case Node.TDeclare(name, expr): return 'TDeclare(\(name),' + TestParser.stringify(expr) + ")"
		case Node.TIs(expr, type): return 'TAs(' + TestParser.stringify(expr) + "," + TestParser.stringifyType(type) + ")"
		case Node.TAs(expr, kind, type): return 'TAs(' + TestParser.stringify(expr) + "," + Token.stringify(kind) + "," + TestParser.stringifyType(type) + ")"
		case Node.TBinop(a, op, b): return 'TBinop(' + TestParser.stringify(a) + ',' + Token.stringify(op) + ',' + TestParser.stringify(b) + ')'
		case Node.TAssignop(a, op, b): return 'TAssignop(' + TestParser.stringify(a) + ',' + Token.stringify(op) + ',' + TestParser.stringify(b) + ')'
		case Node.TBlock(els): return 'TBlock(' + TestParser.stringifyNodeArray(els) + ')'
		case Node.TVar(name, t, expr, const):
		return 'TVar(\(name),' + ((t != null) ? TestParser.stringifyType(t) : "null") +
		"," + ((expr != null) ? TestParser.stringify(expr) : "null") +',\(const))'
		case Node.TVars(vars): return 'TVars(' + TestParser.stringifyNodeArray(vars) + ")"

		case Node.TFunction(name, expr, vars, rettype):
			return 'TFunction(\(name),'
			+ (expr == null ? "null" : TestParser.stringify(expr))
			+ "," + TestParser.stringifyNodeArray(vars) + ',' + ((rettype != null) ? TestParser.stringifyType(rettype) : "null") + ")"

		case Node.TCall(e, el, argNames):
			var res = 'TCall(' + TestParser.stringify(e) + ',['
			for (i in el.length) {
				res += argNames[i] == null ? "" : argNames[i] + ":"
				res += TestParser.stringify(el[i]) + ((i != el.length - 1) ? "," : "")
			}
			return res + "])"

		case Node.TParenthesis(e): return 'TParenthesis(' + TestParser.stringify(e) + ')'
		case Node.TReturn(e): return 'TReturn(' + TestParser.stringify(e) + ')'
		case Node.TThrow(e): return 'TThrow(' + TestParser.stringify(e) + ')'
		case Node.TEnum(t, els): return 'TEnum(' + TestParser.stringifyType(t) + ',' + TestParser.stringifyNodeArray(els) + ')'
		case Node.TUsing(a): return 'TUsing(' + a.join(',') + ")"
		case Node.TModule(paths, els):
			return "TModule(" + paths.join('.') + "," + TestParser.stringifyNodeArray(els) + ")"

		case Node.TMap(k, v): return 'TMap([' + [for(p in k) TestParser.stringify(p)].join(',') + '],[' + [for(p in v) TestParser.stringify(p)].join(',') + '])'

		case Node.TClass(type, extend, implement, fields, external):
			var res = "TClass(" + TestParser.stringifyType(type) + ","
			res += extend != null ? TestParser.stringifyType(extend) : "null" + ","
			res += TestParser.stringifyNodeTypeArray(implement) + ","
			res += TestParser.stringifyNodeArray(fields) + ","
			res += external + ")"
			return res

		case Node.TNew(path, t, args, names, values):
			return 'TNew([' + path.join('.') + '],' + TestParser.stringifyType(t) + ',' + TestParser.stringifyNodeArray(args) + ',[' + names.join(",") + "]," + TestParser.stringifyNodeArray(values) + ")"

		case Node.NodeTypeValue(type): return 'NodeTypeValue(' + TestParser.stringifyType(type) + ")"
		case Node.TDot(l, r): return "TDot(" + TestParser.stringify(l) + "," + r + ")"

		case e: '<!--' + e + '-->'
		}
	}

	static function stringifyNodeArray(arr: Array<Node>) {
		return "[" + [for (e in arr) TestParser.stringify(e)].join(',') + "]"
	}

	static function stringifyNodeTypeArray(arr: Array<NodeType>) {
		return "[" + [for (e in arr) TestParser.stringifyType(e)].join(',') + "]"
	}

	// Creates a testable consistent string representation of type
	static function stringifyType(node: NodeType): String {
		case e: '<!--' + e + '-->'
		switch (node) {
		case NodeType.Type(s): return 'Type(\(s))'
		case NodeType.ParametricType(name, params): return 'ParametricType(\(name),[' + [for(p in params) TestParser.stringifyType(p)].join(',') + "])"
		case NodeType.Function(args, rettype): return 'Function([' + [for (e in args) TestParser.stringifyType(e)].join(',') + "]," + TestParser.stringifyType(rettype) + ')'
		case NodeType.Object(names, types): return 'Object([' + names.join(',') + "],[" + [for (e in types) TestParser.stringifyType(e)].join(',') +"])"
		}
	}
}
}
